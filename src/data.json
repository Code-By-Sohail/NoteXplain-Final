[
    {
        "id": "semester-1",
        "title": "Semester 1",
        "description": "Topic",
        "subjects": [
            {
                "id": "physics",
                "title": "Physics",
                "chapters": [
                    {
                        "id": "mechanics",
                        "title": "Mechanics",
                        "topics": [],
                        "practicals": [
                            {
                                "id": "lab-1",
                                "title": "Lab 1: Velocity",
                                "content": "# Lab 1: Measuring Velocity\n\nThis is a sample practical."
                            }
                        ],
                        "locked": false
                    }
                ],
                "locked": false
            },
            {
                "id": "test-subject",
                "title": "Test Subject",
                "chapters": []
            }
        ],
        "locked": true
    },
    {
        "id": "semester-2",
        "title": "Semester 2",
        "description": "Topic ",
        "subjects": [],
        "locked": true
    },
    {
        "id": "semester-3",
        "title": "Semester 3",
        "description": "Topic ",
        "subjects": [],
        "locked": true
    },
    {
        "id": "semester-4",
        "title": "Semester 4",
        "description": "Topic",
        "subjects": [
            {
                "id": "ada-be04000241",
                "title": "ADA (BE04000241)",
                "chapters": [],
                "practicals": [
                    {
                        "id": "practical-1",
                        "title": "Practical 1",
                        "content": "**1) Aim: Perform the following sorting operations and measure the execution time for sufficiently large input: Selection Sort, Bubble Sort, and Insertion Sort.** \n\n<mark>Selection Sort</mark>\n\n```c\n#include <stdio.h>\n#include <time.h>\n\nvoid selectionSort(int arr[], int n)\n{\n    int i, j, min, temp;\n    for (i = 0; i < n - 1; i++)\n    {\n        min = i;\n        for (j = i + 1; j < n; j++)\n        {\n            if (arr[j] < arr[min])\n                min = j;\n        }\n        temp = arr[i];\n        arr[i] = arr[min];\n        arr[min] = temp;\n    }\n}\n\nint main()\n{\n    int n = 5000;\n    int arr[5000];\n    int i;\n\n    for (i = 0; i < n; i++)\n        arr[i] = n - i;\n\n    clock_t start = clock();\n    selectionSort(arr, n);\n    clock_t end = clock();\n\n    double time_taken = (double)(end - start) / CLOCKS_PER_SEC;\n    printf(\"Selection Sort Execution Time: %f seconds\\n\", time_taken);\n\n    return 0;\n}\n\n```\n \n**Note: The output may vary on different systems because it depends on the system’s execution speed and performance.** \n```output\nSelection Sort Execution Time: 0.12 seconds\n\n```\n\n------------------------------------------------------------------------------------------------------------------------------------------\n\n<mark>Bubble Sort</mark> \n\n```c\n#include <stdio.h>\n#include <time.h>\n\nvoid bubbleSort(int arr[], int n)\n{\n    int i, j, temp;\n    for (i = 0; i < n - 1; i++)\n    {\n        for (j = 0; j < n - i - 1; j++)\n        {\n            if (arr[j] > arr[j + 1])\n            {\n                temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main()\n{\n    int n = 5000;\n    int arr[5000];\n    int i;\n\n    for (i = 0; i < n; i++)\n        arr[i] = n - i;\n\n    clock_t start = clock();\n    bubbleSort(arr, n);\n    clock_t end = clock();\n\n    double time_taken = (double)(end - start) / CLOCKS_PER_SEC;\n    printf(\"Bubble Sort Execution Time: %f seconds\\n\", time_taken);\n\n    return 0;\n}\n\n\n```\n**Note: The output may vary on different systems because it depends on the system’s execution speed and performance.** \n```output\nBubble Sort Execution Time: 0.21 seconds\n\n```\n------------------------------------------------------------------------------------------------------------------------------------------\n\n<mark>Insertion Sort</mark> \n\n```c\n#include <stdio.h>\n#include <time.h>\n\nvoid insertionSort(int arr[], int n)\n{\n    int i, key, j;\n    for (i = 1; i < n; i++)\n    {\n        key = arr[i];\n        j = i - 1;\n        while (j >= 0 && arr[j] > key)\n        {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}\n\nint main()\n{\n    int n = 5000;\n    int arr[5000];\n    int i;\n\n    for (i = 0; i < n; i++)\n        arr[i] = n - i;\n\n    clock_t start = clock();\n    insertionSort(arr, n);\n    clock_t end = clock();\n\n    double time_taken = (double)(end - start) / CLOCKS_PER_SEC;\n    printf(\"Insertion Sort Execution Time: %f seconds\\n\", time_taken);\n\n    return 0;\n}\n\n```\n**Note: The output may vary on different systems because it depends on the system’s execution speed and performance.** \n```output\nInsertion Sort Execution Time: 0.24 seconds\n\n```\n\n\n<mark>Time Complexity Table</mark>\n| Sorting Algorithm | Selection Sort | Bubble Sort | Insertion Sort |\n| :--- | :--- | :--- | :--- |\n| Worst Case | O(n²) | O(n²) | O(n²) |\n| Best Case | O(n²) | O(n) | O(n) |\n| Average Case | O(n²) | O(n²) | O(n²) |"
                    },
                    {
                        "id": "practical-2",
                        "title": "Practical 2",
                        "content": "**Aim-Implement Linear Search and Binary Search** \n\n<mark>or</mark> \n\n**Aim-Implementation and Time Analysis of Linear Search and Binary Search Algorithm**\n\n<mark>A. Linear Search</mark> \n```c\n#include <stdio.h>\n\nint main()\n{\n    int n, i, search, found = 0;\n\n    printf(\"Enter the size of Array : \");\n    scanf(\"%d\", &n);\n\n    int arr[n];\n\n    printf(\"\\nEnter the elements of Array:\\n\");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"Element %d : \", i + 1);\n        scanf(\"%d\", &arr[i]);\n    }\n\n    printf(\"\\nWhich element you want to find : \");\n    scanf(\"%d\", &search);\n\n    for (i = 0; i < n; i++)\n    {\n        if (search == arr[i])\n        {\n            printf(\"\\nThe element %d found at index : %d\", search, i);\n            found = 1;\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        printf(\"\\nThe element %d is not found\", search);\n    }\n\n    return 0;\n}\n\n```\n```output\nEnter the size of Array : 5\n\nEnter the elements of Array:\nElement 1 : 10\nElement 2 : 20\nElement 3 : 30\nElement 4 : 40\nElement 5 : 50\n\nWhich element you want to find : 30\n\nThe element 30 found at index : 2\n\n```\n\n\n\n\n\n<mark>B. Binary Search</mark> \n\n **Note: Binary Search works only on sorted arrays** \n```c\n#include <stdio.h>\n\n// Function to perform Binary Search\nint binarySearch(int arr[], int size, int target)\n{\n    int low = 0;\n    int high = size - 1;\n\n    while (low <= high)\n    {\n        int mid = (low + high) / 2;\n\n        if (arr[mid] == target)\n            return mid;\n        else if (arr[mid] < target)\n            low = mid + 1;\n        else\n            high = mid - 1;\n    }\n\n    return -1;\n}\n\nint main()\n{\n    int n, i, target, result;\n\n    printf(\"Enter the size of Array : \");\n    scanf(\"%d\", &n);\n\n    int arr[n];\n\n    printf(\"\\nEnter elements of Array (in sorted order):\\n\");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"Element %d : \", i + 1);\n        scanf(\"%d\", &arr[i]);\n    }\n\n    printf(\"\\nWhich element you want to find : \");\n    scanf(\"%d\", &target);\n\n    result = binarySearch(arr, n, target);\n\n    if (result != -1)\n        printf(\"\\nThe element %d found at index : %d\", target, result);\n    else\n        printf(\"\\nThe element %d is not found\", target);\n\n    return 0;\n}\n\n```\n```output\nEnter the size of Array : 5\n\nEnter elements of Array (in sorted order):\nElement 1 : 10\nElement 2 : 20\nElement 3 : 30\nElement 4 : 40\nElement 5 : 50\n\nWhich element you want to find : 40\n\nThe element 40 found at index : 3\n\n```\n\n<mark>Time Complexity Table</mark> \n| Search Algorithm | Linear Search | Binary Search |\n| :--- | :--- | :--- |\n| **Worst Case** | O(n) | O(log n) |\n| **Best Case** | O(1) | O(1) |\n| **Average Case** | O(n) | O(log n) |\n"
                    },
                    {
                        "id": "practical-3",
                        "title": "Practical 3",
                        "content": "**3) Aim: Perform the following sorting operations and measure the execution time for sufficiently large input: Merge Sort and Quick Sort.** \n\n<mark>A. Merge Sort</mark> \n\n```c\n#include <stdio.h>\n#include <time.h>\n\nvoid merge(int arr[], int l, int m, int r)\n{\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n\n    int L[n1], R[n2];\n\n    for (i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n\n    i = 0; \n    j = 0; \n    k = l;\n\n    while (i < n1 && j < n2)\n    {\n        if (L[i] <= R[j])\n            arr[k++] = L[i++];\n        else\n            arr[k++] = R[j++];\n    }\n\n    while (i < n1)\n        arr[k++] = L[i++];\n\n    while (j < n2)\n        arr[k++] = R[j++];\n}\n\nvoid mergeSort(int arr[], int l, int r)\n{\n    if (l < r)\n    {\n        int m = (l + r) / 2;\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}\n\nint main()\n{\n    int n = 5000;\n    int arr[5000];\n    int i;\n\n    for (i = 0; i < n; i++)\n        arr[i] = n - i;\n\n    clock_t start = clock();\n    mergeSort(arr, 0, n - 1);\n    clock_t end = clock();\n\n    double time_taken = (double)(end - start) / CLOCKS_PER_SEC;\n    printf(\"Merge Sort Execution Time: %f seconds\\n\", time_taken);\n\n    return 0;\n}\n\n```\n**The output may vary on different systems because it depends on the system’s execution speed and performance.** \n```output\nMerge Sort Execution Time: 0.03 seconds\n\n```\n\n------------------------------------------------------------------------------------------------------------------------------------------\n\n<mark>B. Quick Sort</mark> \n\n```c\n#include <stdio.h>\n#include <time.h>\n\nint partition(int arr[], int low, int high)\n{\n    int pivot = arr[high];\n    int i = low - 1;\n    int temp;\n\n    for (int j = low; j < high; j++)\n    {\n        if (arr[j] < pivot)\n        {\n            i++;\n            temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n\n    temp = arr[i + 1];\n    arr[i + 1] = arr[high];\n    arr[high] = temp;\n\n    return i + 1;\n}\n\nvoid quickSort(int arr[], int low, int high)\n{\n    if (low < high)\n    {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nint main()\n{\n    int n = 5000;\n    int arr[5000];\n    int i;\n\n    for (i = 0; i < n; i++)\n        arr[i] = n - i;\n\n    clock_t start = clock();\n    quickSort(arr, 0, n - 1);\n    clock_t end = clock();\n\n    double time_taken = (double)(end - start) / CLOCKS_PER_SEC;\n    printf(\"Quick Sort Execution Time: %f seconds\\n\", time_taken);\n\n    return 0;\n}\n\n```\n**The output may vary on different systems because it depends on the system’s execution speed and performance.** \n```output\nQuick Sort Execution Time: 0.02 seconds\n\n```\n\n<mark>Time Complexity Table</mark>\n| Case | Merge Sort | Quick Sort |\n| :--- | :--- | :--- |\n| **Best Case** | O(n log n) | O(n log n) |\n| **Average Case** | O(n log n) | O(n log n) |\n| **Worst Case** | O(n log n) | O(n²) |\n| **Space Complexity** | O(n) | O(log n) |\n| **Stability** | Stable | Not Stable |\n"
                    },
                    {
                        "id": "practical-4",
                        "title": "practical 4",
                        "content": "**4) Aim: Solve the given problems using Greedy Strategy:Make a Change Problem and Activity Selection Problem.** \n\n<mark>A. Make a Change Problem (Greedy Strategy)</mark>\n\n```c\n#include <stdio.h>\n\nint main()\n{\n    int coins[] = {50, 20, 10, 5, 2, 1};\n    int n = 6;\n    int amount, i;\n\n    printf(\"Enter the amount: \");\n    scanf(\"%d\", &amount);\n\n    printf(\"Coins used to make change:\\n\");\n\n    for (i = 0; i < n; i++)\n    {\n        while (amount >= coins[i])\n        {\n            printf(\"%d \", coins[i]);\n            amount -= coins[i];\n        }\n    }\n\n    return 0;\n}\n\n```\n**Note: The data used in this program is only for understanding and demonstration purposes.** \n```output\nEnter the amount: 93\nCoins used to make change:\n50 20 20 2 1\n\n```\n------------------------------------------------------------------------------------------------------------------------------------------\n<mark>B. Activity Selection Problem (Greedy Strategy)</mark>\n\n```c\n#include <stdio.h>\n\nint main()\n{\n    int start[] = {1, 3, 0, 5, 8, 5};\n    int finish[] = {2, 4, 6, 7, 9, 9};\n    int n = 6;\n\n    int i, last = 0;\n\n    printf(\"Selected Activities:\\n\");\n    printf(\"Activity %d (Start: %d, Finish: %d)\\n\", \n            1, start[0], finish[0]);\n\n    for (i = 1; i < n; i++)\n    {\n        if (start[i] >= finish[last])\n        {\n            printf(\"Activity %d (Start: %d, Finish: %d)\\n\", \n                    i + 1, start[i], finish[i]);\n            last = i;\n        }\n    }\n\n    return 0;\n}\n\n```\n\n**Note: The data used in this program is only for understanding and demonstration purposes.** \n```output\nSelected Activities:\nActivity 1 (Start: 1, Finish: 2)\nActivity 2 (Start: 3, Finish: 4)\nActivity 4 (Start: 5, Finish: 7)\nActivity 5 (Start: 8, Finish: 9)\n\n```\n\n\n\n<mark>Time Complexity Table</mark>\n| Problem | Best Case | Average Case | Worst Case |\n| :--- | :--- | :--- | :--- |\n| **Make a Change Problem** | O(n) | O(n) | O(n) |\n| **Activity Selection Problem** | O(n log n) | O(n log n) | O(n log n) |\n"
                    },
                    {
                        "id": "practical-5",
                        "title": "Practical 5",
                        "content": "**5) Aim: Solve the given problems using Greedy Strategy:Fractional Knapsack Problem, 0/1 Knapsack Problem, and Job Scheduling Problem.**\n\n<mark>A. Fractional Knapsack Problem (Greedy Strategy)</mark>\n\n```c\n#include <stdio.h>\n\nint main()\n{\n    int n = 3;\n    int value[] = {60, 100, 120};\n    int weight[] = {10, 20, 30};\n    int capacity = 50;\n\n    float ratio[3], totalValue = 0.0;\n    int i, j;\n\n    for (i = 0; i < n; i++)\n        ratio[i] = (float)value[i] / weight[i];\n\n    for (i = 0; i < n - 1; i++)\n    {\n        for (j = i + 1; j < n; j++)\n        {\n            if (ratio[i] < ratio[j])\n            {\n                float tempR = ratio[i];\n                ratio[i] = ratio[j];\n                ratio[j] = tempR;\n\n                int tempV = value[i];\n                value[i] = value[j];\n                value[j] = tempV;\n\n                int tempW = weight[i];\n                weight[i] = weight[j];\n                weight[j] = tempW;\n            }\n        }\n    }\n\n    for (i = 0; i < n; i++)\n    {\n        if (capacity >= weight[i])\n        {\n            capacity -= weight[i];\n            totalValue += value[i];\n        }\n        else\n        {\n            totalValue += ratio[i] * capacity;\n            break;\n        }\n    }\n\n    printf(\"Maximum value in Fractional Knapsack = %.2f\\n\", totalValue);\n    return 0;\n}\n\n```\n**Note: The data used in these programs is only for understanding and demonstration purposes.Output may vary depending on the system and input data.** \n```output\nMaximum value in Fractional Knapsack = 240.00\n\n```\n\n------------------------------------------------------------------------------------------------------------------------------------------\n<mark>B. 0/1 Knapsack Problem</mark>\n\n```c\n#include <stdio.h>\n\nint max(int a, int b)\n{\n    return (a > b) ? a : b;\n}\n\nint main()\n{\n    int n = 3;\n    int value[] = {60, 100, 120};\n    int weight[] = {10, 20, 30};\n    int capacity = 50;\n\n    int dp[n + 1][capacity + 1];\n    int i, w;\n\n    for (i = 0; i <= n; i++)\n    {\n        for (w = 0; w <= capacity; w++)\n        {\n            if (i == 0 || w == 0)\n                dp[i][w] = 0;\n            else if (weight[i - 1] <= w)\n                dp[i][w] = max(value[i - 1] +\n                               dp[i - 1][w - weight[i - 1]],\n                               dp[i - 1][w]);\n            else\n                dp[i][w] = dp[i - 1][w];\n        }\n    }\n\n    printf(\"Maximum value in 0/1 Knapsack = %d\\n\", dp[n][capacity]);\n    return 0;\n}\n\n```\n**Note: The data used in these programs is only for understanding and demonstration purposes.Output may vary depending on the system and input data.**\n```output\nMaximum value in 0/1 Knapsack = 220\n\n```\n\n------------------------------------------------------------------------------------------------------------------------------------------\n<mark>C. Job Scheduling Problem (Greedy Strategy)</mark>\n\n```c\n#include <stdio.h>\n\nstruct Job\n{\n    char id;\n    int deadline;\n    int profit;\n};\n\nint main()\n{\n    struct Job jobs[] = {\n        {'A', 2, 100},\n        {'B', 1, 19},\n        {'C', 2, 27},\n        {'D', 1, 25},\n        {'E', 3, 15}\n    };\n\n    int n = 5;\n    int i, j;\n\n    for (i = 0; i < n - 1; i++)\n    {\n        for (j = i + 1; j < n; j++)\n        {\n            if (jobs[i].profit < jobs[j].profit)\n            {\n                struct Job temp = jobs[i];\n                jobs[i] = jobs[j];\n                jobs[j] = temp;\n            }\n        }\n    }\n\n    int slot[10] = {0};\n    char result[10];\n\n    for (i = 0; i < n; i++)\n    {\n        for (j = jobs[i].deadline - 1; j >= 0; j--)\n        {\n            if (slot[j] == 0)\n            {\n                slot[j] = 1;\n                result[j] = jobs[i].id;\n                break;\n            }\n        }\n    }\n\n    printf(\"Scheduled Jobs: \");\n    for (i = 0; i < 10; i++)\n    {\n        if (slot[i])\n            printf(\"%c \", result[i]);\n    }\n\n    return 0;\n}\n)\n```\n**Note: The data used in these programs is only for understanding and demonstration purposes.Output may vary depending on the system and input data.**\n```output\nScheduled Jobs: A C E\n\n```\n\n\n<mark>Time Complexity Table</mark>\n| Problem | Best Case | Average Case | Worst Case |\n| :--- | :--- | :--- | :--- |\n| **Fractional Knapsack Problem** | O(n log n) | O(n log n) | O(n log n) |\n| **0/1 Knapsack Problem** | O(2ⁿ) | O(2ⁿ) | O(2ⁿ) |\n| **Job Scheduling Problem** | O(n log n) | O(n log n) | O(n log n) |\n\n\n"
                    },
                    {
                        "id": "practical-6",
                        "title": "Practical 6",
                        "content": "**6) Aim: Solve the given problems using Greedy Strategy:Minimum Spanning Tree using Prim’s Algorithm and Kruskal’s Algorithm.**\n\n<mark>A. Minimum Spanning Tree using Prim’s Algorithm</mark>\n\n```c\n#include <stdio.h>\n#include <limits.h>\n\n#define V 5\n\nint minKey(int key[], int mstSet[])\n{\n    int min = INT_MAX, min_index;\n\n    for (int v = 0; v < V; v++)\n        if (mstSet[v] == 0 && key[v] < min)\n            min = key[v], min_index = v;\n\n    return min_index;\n}\n\nvoid primMST(int graph[V][V])\n{\n    int parent[V];\n    int key[V];\n    int mstSet[V];\n\n    for (int i = 0; i < V; i++)\n        key[i] = INT_MAX, mstSet[i] = 0;\n\n    key[0] = 0;\n    parent[0] = -1;\n\n    for (int count = 0; count < V - 1; count++)\n    {\n        int u = minKey(key, mstSet);\n        mstSet[u] = 1;\n\n        for (int v = 0; v < V; v++)\n            if (graph[u][v] && mstSet[v] == 0 && graph[u][v] < key[v])\n                parent[v] = u, key[v] = graph[u][v];\n    }\n\n    printf(\"Edge \\tWeight\\n\");\n    for (int i = 1; i < V; i++)\n        printf(\"%d - %d \\t%d\\n\", parent[i], i, graph[i][parent[i]]);\n}\n\nint main()\n{\n    int graph[V][V] = {\n        {0, 2, 0, 6, 0},\n        {2, 0, 3, 8, 5},\n        {0, 3, 0, 0, 7},\n        {6, 8, 0, 0, 9},\n        {0, 5, 7, 9, 0}\n    };\n\n    primMST(graph);\n    return 0;\n}\n\n```\n**Note: The data used in these programs is only for understanding and demonstration purposes. Output may vary depending on the system and input graph.** \n```output\nEdge    Weight\n0 - 1   2\n1 - 2   3\n0 - 3   6\n1 - 4   5\n\n```\n\n--------------------------------------------------------------------------------------------------\n<mark>B. Minimum Spanning Tree using Kruskal’s Algorithm</mark>\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define V 5\n#define E 7\n\nstruct Edge\n{\n    int src, dest, weight;\n};\n\nstruct Subset\n{\n    int parent;\n    int rank;\n};\n\nint find(struct Subset subsets[], int i)\n{\n    if (subsets[i].parent != i)\n        subsets[i].parent = find(subsets, subsets[i].parent);\n    return subsets[i].parent;\n}\n\nvoid Union(struct Subset subsets[], int x, int y)\n{\n    int xroot = find(subsets, x);\n    int yroot = find(subsets, y);\n\n    if (subsets[xroot].rank < subsets[yroot].rank)\n        subsets[xroot].parent = yroot;\n    else if (subsets[xroot].rank > subsets[yroot].rank)\n        subsets[yroot].parent = xroot;\n    else\n    {\n        subsets[yroot].parent = xroot;\n        subsets[xroot].rank++;\n    }\n}\n\nint compare(const void *a, const void *b)\n{\n    struct Edge *a1 = (struct Edge *)a;\n    struct Edge *b1 = (struct Edge *)b;\n    return a1->weight - b1->weight;\n}\n\nvoid kruskalMST(struct Edge edges[])\n{\n    struct Edge result[V];\n    int e = 0, i = 0;\n\n    qsort(edges, E, sizeof(edges[0]), compare);\n\n    struct Subset subsets[V];\n    for (int v = 0; v < V; v++)\n    {\n        subsets[v].parent = v;\n        subsets[v].rank = 0;\n    }\n\n    while (e < V - 1 && i < E)\n    {\n        struct Edge next = edges[i++];\n        int x = find(subsets, next.src);\n        int y = find(subsets, next.dest);\n\n        if (x != y)\n        {\n            result[e++] = next;\n            Union(subsets, x, y);\n        }\n    }\n\n    printf(\"Edge \\tWeight\\n\");\n    for (i = 0; i < e; i++)\n        printf(\"%d - %d \\t%d\\n\", result[i].src, result[i].dest, result[i].weight);\n}\n\nint main()\n{\n    struct Edge edges[E] = {\n        {0, 1, 2},\n        {0, 3, 6},\n        {1, 2, 3},\n        {1, 3, 8},\n        {1, 4, 5},\n        {2, 4, 7},\n        {3, 4, 9}\n    };\n\n    kruskalMST(edges);\n    return 0;\n}\n\n```\n**Note: The data used in these programs is only for understanding and demonstration purposes. Output may vary depending on the system and input graph.** \n```output\nEdge    Weight\n0 - 1   2\n1 - 2   3\n1 - 4   5\n0 - 3   6\n\n```\n\n\n<mark>Time Complexity Table</mark>\n| Algorithm | Best Case | Average Case | Worst Case |\n| :--- | :--- | :--- | :--- |\n| **Prim’s Algorithm** | O(E log V) | O(E log V) | O(E log V) |\n| **Kruskal’s Algorithm** | O(E log E) | O(E log E) | O(E log E) |\n\n"
                    },
                    {
                        "id": "practical-7",
                        "title": "Practical 7",
                        "content": "**7) Aim: Solve the given problems using Dynamic Programming:Make a Change Problem and 0/1 Knapsack Problem.**\n\n<mark>A. Make a Change Problem (Dynamic Programming)</mark>\n\n```c\n#include <stdio.h>\n#include <limits.h>\n\nint min(int a, int b)\n{\n    return (a < b) ? a : b;\n}\n\nint main()\n{\n    int coins[] = {1, 3, 4};\n    int n = 3;\n    int amount;\n\n    printf(\"Enter the target amount: \");\n    scanf(\"%d\", &amount);\n\n    int dp[amount + 1];\n    dp[0] = 0;\n\n    for (int i = 1; i <= amount; i++)\n        dp[i] = INT_MAX;\n\n    for (int i = 1; i <= amount; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (coins[j] <= i && dp[i - coins[j]] != INT_MAX)\n                dp[i] = min(dp[i], dp[i - coins[j]] + 1);\n        }\n    }\n\n    if (dp[amount] == INT_MAX)\n        printf(\"Change cannot be made for amount %d\\n\", amount);\n    else\n        printf(\"Minimum coins required: %d\\n\", dp[amount]);\n\n    return 0;\n}\n\n```\n**Note: The data used in these programs is only for understanding and demonstration purposes. Output may vary depending on the system and input values.** \n```output\nEnter the target amount: 6\nMinimum coins required: 2\n\n```\n\n-------------------------------------------------------------------------------------------------\n<mark>B. 0/1 Knapsack Problem (Dynamic Programming)</mark>\n\n```c\n#include <stdio.h>\n\nint max(int a, int b)\n{\n    return (a > b) ? a : b;\n}\n\nint main()\n{\n    int n = 3;\n    int value[] = {60, 100, 120};\n    int weight[] = {10, 20, 30};\n    int capacity = 50;\n\n    int dp[n + 1][capacity + 1];\n\n    for (int i = 0; i <= n; i++)\n    {\n        for (int w = 0; w <= capacity; w++)\n        {\n            if (i == 0 || w == 0)\n                dp[i][w] = 0;\n            else if (weight[i - 1] <= w)\n                dp[i][w] = max(value[i - 1] +\n                               dp[i - 1][w - weight[i - 1]],\n                               dp[i - 1][w]);\n            else\n                dp[i][w] = dp[i - 1][w];\n        }\n    }\n\n    printf(\"Maximum value in 0/1 Knapsack = %d\\n\", dp[n][capacity]);\n    return 0;\n}\n\n```\n**Note: The data used in these programs is only for understanding and demonstration purposes. Output may vary depending on the system and input values.** \n```output\nMaximum value in 0/1 Knapsack = 220\n\n```\n\n\n<mark>Time Complexity Table</mark>\n| Problem | Best Case | Average Case | Worst Case |\n| :--- | :--- | :--- | :--- |\n| **Make a Change Problem (DP)** | O(n × amount) | O(n × amount) | O(n × amount) |\n| **0/1 Knapsack Problem (DP)** | O(n × W) | O(n × W) | O(n × W) |\n"
                    },
                    {
                        "id": "practical-8",
                        "title": "Practical 8",
                        "content": "**Aim : Implementation of chain matrix multiplication using dynamic programming.** \n\n```c\n#include <stdio.h>\n#include <limits.h>\n\n// Function for Matrix Chain Multiplication using DP\nint MatrixChainMultiplication(int p[], int n)\n{\n    int m[n][n];\n    int i, j, k, L, q;\n\n    // Cost is zero when multiplying one matrix\n    for (i = 1; i < n; i++)\n        m[i][i] = 0;\n\n    // L is chain length\n    for (L = 2; L < n; L++)\n    {\n        for (i = 1; i < n - L + 1; i++)\n        {\n            j = i + L - 1;\n            m[i][j] = INT_MAX;\n\n            for (k = i; k <= j - 1; k++)\n            {\n                q = m[i][k] + m[k + 1][j]\n                    + p[i - 1] * p[k] * p[j];\n\n                if (q < m[i][j])\n                    m[i][j] = q;\n            }\n        }\n    }\n\n    return m[1][n - 1];\n}\n\nint main()\n{\n    int n, i;\n\n    printf(\"Enter number of matrices: \");\n    scanf(\"%d\", &n);\n\n    // Number of dimensions = matrices + 1\n    n = n + 1;\n\n    int arr[n];\n\n    printf(\"Enter dimensions:\\n\");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"Enter d%d: \", i);\n        scanf(\"%d\", &arr[i]);\n    }\n\n    printf(\"\\nMinimum number of multiplications is %d\\n\",\n           MatrixChainMultiplication(arr, n));\n\n    return 0;\n}\n\n```\n\n```output\nEnter number of matrices: 3\nEnter dimensions:\nEnter d0: 10\nEnter d1: 20\nEnter d2: 30\nEnter d3: 40\n\nMinimum number of multiplications is 18000\n\n```\n<mark>Time Complexity Table</mark> \n| Problem | Best Case | Worst Case | Average Case |\n| :--- | :--- | :--- | :--- |\n| **Matrix Chain Multiplication** | O(n³) | O(n³) | O(n³) |\n\n"
                    },
                    {
                        "id": "practical-9",
                        "title": "Practical 9 ",
                        "content": "**9) Aim: Solve the given problems using Dynamic Programming:Longest Common Subsequence (LCS) and Shortest Common Supersequence (SCS)**\n\n<mark>A. Longest Common Subsequence (LCS)</mark>\n\n```c\n#include <stdio.h>\n#include <string.h>\n\n// Function to find LCS length\nint LCS(char X[], char Y[])\n{\n    int m = strlen(X);\n    int n = strlen(Y);\n    int dp[m + 1][n + 1];\n\n    for (int i = 0; i <= m; i++)\n    {\n        for (int j = 0; j <= n; j++)\n        {\n            if (i == 0 || j == 0)\n                dp[i][j] = 0;\n            else if (X[i - 1] == Y[j - 1])\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            else\n                dp[i][j] = (dp[i - 1][j] > dp[i][j - 1]) ?\n                            dp[i - 1][j] : dp[i][j - 1];\n        }\n    }\n\n    return dp[m][n];\n}\n\nint main()\n{\n    char X[] = \"NOTE\";\n    char Y[] = \"XPLAIN\";\n\n    printf(\"String X: %s\\n\", X);\n    printf(\"String Y: %s\\n\", Y);\n\n    printf(\"Length of LCS: %d\\n\", LCS(X, Y));\n\n    return 0;\n}\n\n```\n**Note: The data used in this program is only for understanding and demonstration purposes. Output may vary depending on the system and input strings.** \n```output\nString X: NOTE\nString Y: XPLAIN\nLength of LCS: 1\n\n```\n\n--------------------------------------------------------------------------------------------------\n<mark>B. Shortest Common Supersequence (SCS)</mark>\n\n**Formula used : SCS Length = Length(X) + Length(Y) − Length(LCS)**  \n\n```c\n#include <stdio.h>\n#include <string.h>\n\n// Function to find LCS length\nint LCS(char X[], char Y[])\n{\n    int m = strlen(X);\n    int n = strlen(Y);\n    int dp[m + 1][n + 1];\n\n    for (int i = 0; i <= m; i++)\n    {\n        for (int j = 0; j <= n; j++)\n        {\n            if (i == 0 || j == 0)\n                dp[i][j] = 0;\n            else if (X[i - 1] == Y[j - 1])\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            else\n                dp[i][j] = (dp[i - 1][j] > dp[i][j - 1]) ?\n                            dp[i - 1][j] : dp[i][j - 1];\n        }\n    }\n\n    return dp[m][n];\n}\n\nint main()\n{\n    char X[] = \"NOTE\";\n    char Y[] = \"XPLAIN\";\n\n    int lcs = LCS(X, Y);\n    int scs_length = strlen(X) + strlen(Y) - lcs;\n\n    printf(\"String X: %s\\n\", X);\n    printf(\"String Y: %s\\n\", Y);\n    printf(\"Length of LCS: %d\\n\", lcs);\n    printf(\"Length of SCS: %d\\n\", scs_length);\n\n    return 0;\n}\n\n```\n**Note: The data used in this program is only for understanding and demonstration purposes. Output may vary depending on the system and input strings.** \n```output\nString X: NOTE\nString Y: XPLAIN\nLength of LCS: 1\nLength of SCS: 9\n\n```\n<mark>Time Complexity Table</mark>\n| Problem | Best Case | Average Case | Worst Case |\n| :--- | :--- | :--- | :--- |\n| **Longest Common Subsequence (LCS)** | O(m × n) | O(m × n) | O(m × n) |\n| **Shortest Common Supersequence (SCS)** | O(m × n) | O(m × n) | O(m × n) |\n\n"
                    },
                    {
                        "id": "practical-10",
                        "title": "Practical 10 ",
                        "content": "**10) Aim: Solve the following problems using Backtracking:4-Queen Problem and 8-Queen Problem**\n\n<mark>A. 4-Queen Problem (Backtracking)</mark>\n\n\n```c\n#include <stdio.h>\n#define N 4\n\nint board[N][N];\n\nint isSafe(int row, int col)\n{\n    for (int i = 0; i < col; i++)\n        if (board[row][i])\n            return 0;\n\n    for (int i = row, j = col; i >= 0 && j >= 0; i--, j--)\n        if (board[i][j])\n            return 0;\n\n    for (int i = row, j = col; i < N && j >= 0; i++, j--)\n        if (board[i][j])\n            return 0;\n\n    return 1;\n}\n\nint solveNQueen(int col)\n{\n    if (col >= N)\n        return 1;\n\n    for (int i = 0; i < N; i++)\n    {\n        if (isSafe(i, col))\n        {\n            board[i][col] = 1;\n\n            if (solveNQueen(col + 1))\n                return 1;\n\n            board[i][col] = 0;\n        }\n    }\n    return 0;\n}\n\nvoid printBoard()\n{\n    for (int i = 0; i < N; i++)\n    {\n        for (int j = 0; j < N; j++)\n            printf(\"%d \", board[i][j]);\n        printf(\"\\n\");\n    }\n}\n\nint main()\n{\n    if (solveNQueen(0))\n    {\n        printf(\"Solution for 4-Queen Problem:\\n\");\n        printBoard();\n    }\n    else\n    {\n        printf(\"No solution exists\\n\");\n    }\n    return 0;\n}\n\n```\n**Note: The data and solutions shown in these programs are only for understanding and demonstration purposes.Output may vary depending on the system and problem size.** \n```output\nSolution for 4-Queen Problem:\n0 0 1 0\n1 0 0 0\n0 0 0 1\n0 1 0 0\n\n```\n\n\n--------------------------------------------------------------------------------------------------\n\n<mark>B. 8-Queen Problem (Backtracking)</mark>\n\n\n```c\n#include <stdio.h>\n#define N 8\n\nint board[N][N];\n\nint isSafe(int row, int col)\n{\n    for (int i = 0; i < col; i++)\n        if (board[row][i])\n            return 0;\n\n    for (int i = row, j = col; i >= 0 && j >= 0; i--, j--)\n        if (board[i][j])\n            return 0;\n\n    for (int i = row, j = col; i < N && j >= 0; i++, j--)\n        if (board[i][j])\n            return 0;\n\n    return 1;\n}\n\nint solveNQueen(int col)\n{\n    if (col >= N)\n        return 1;\n\n    for (int i = 0; i < N; i++)\n    {\n        if (isSafe(i, col))\n        {\n            board[i][col] = 1;\n\n            if (solveNQueen(col + 1))\n                return 1;\n\n            board[i][col] = 0;\n        }\n    }\n    return 0;\n}\n\nvoid printBoard()\n{\n    for (int i = 0; i < N; i++)\n    {\n        for (int j = 0; j < N; j++)\n            printf(\"%d \", board[i][j]);\n        printf(\"\\n\");\n    }\n}\n\nint main()\n{\n    if (solveNQueen(0))\n    {\n        printf(\"Solution for 8-Queen Problem:\\n\");\n        printBoard();\n    }\n    else\n    {\n        printf(\"No solution exists\\n\");\n    }\n    return 0;\n}\n\n```\n**Note: The data and solutions shown in these programs are only for understanding and demonstration purposes.Output may vary depending on the system and problem size.** \n```output\nSolution for 8-Queen Problem:\n1 0 0 0 0 0 0 0\n0 0 0 0 1 0 0 0\n0 0 0 0 0 0 1 0\n0 0 0 0 0 1 0 0\n0 1 0 0 0 0 0 0\n0 0 0 1 0 0 0 0\n0 0 0 0 0 0 0 1\n0 0 1 0 0 0 0 0\n\n```\n<mark>Time Complexity Table</mark>\n| Problem | Best Case | Average Case | Worst Case |\n| :--- | :--- | :--- | :--- |\n| **4-Queen Problem** | O(N!) | O(N!) | O(N!) |\n| **8-Queen Problem** | O(N!) | O(N!) | O(N!) |\n"
                    }
                ],
                "locked": false
            },
            {
                "id": "os--be04000221",
                "title": "OS  (BE04000221)",
                "chapters": [],
                "locked": true
            },
            {
                "id": "oop--be04000231",
                "title": "OOP  (BE04000231)",
                "chapters": [],
                "locked": true
            },
            {
                "id": "coa-be04000251",
                "title": "COA (BE04000251)",
                "chapters": [],
                "locked": true
            },
            {
                "id": "dm--be04000261",
                "title": "DM  (BE04000261)",
                "chapters": [],
                "locked": true
            }
        ]
    },
    {
        "id": "semester-5",
        "title": "Semester 5",
        "description": "Topic",
        "subjects": [
            {
                "id": "computer-networks",
                "title": "Computer Networks",
                "chapters": [
                    {
                        "id": "computer-networks",
                        "title": "Chapter-1  Computer Networks",
                        "topics": [
                            {
                                "id": "what-is-computer-networks",
                                "title": "what is Computer Networks",
                                "content": "| Feature | LAN | MAN | WAN |\n| :--- | :--- | :--- | :--- |\n| **Definition** | Small area network | City level network | Large area network |\n| **Coverage Area** | Home, school, office | City or campus | Country or world |\n| **Range** | Up to few km | 10–100 km | Beyond 100 km |\n| **Speed** | High | Moderate | Low |\n| **Cost** | Low | Medium | High |\n| **Maintenance** | Easy | Moderate | Difficult |\n| **Example** | School lab | City cable network | Internet |\n",
                                "locked": false
                            }
                        ],
                        "practicals": [],
                        "locked": false
                    },
                    {
                        "id": "chapter-2----application-layer-",
                        "title": "Chapter-2   Application Layer ",
                        "topics": [],
                        "practicals": []
                    },
                    {
                        "id": "chapter-3--transport-layer",
                        "title": "Chapter-3  Transport layer",
                        "topics": [],
                        "practicals": []
                    },
                    {
                        "id": "chapter-4--network-layer",
                        "title": "Chapter-4  Network Layer",
                        "topics": [],
                        "practicals": []
                    },
                    {
                        "id": "chapter-5--the-link-layer-and-local-area-network",
                        "title": "Chapter-5  The Link Layer and Local Area Network",
                        "topics": [],
                        "practicals": []
                    }
                ],
                "practicals": [
                    {
                        "id": "practical-1",
                        "title": "Practical 1",
                        "content": "# Practical 1\n\nThis is your first practical.",
                        "locked": false
                    }
                ]
            },
            {
                "id": "python-for--data-science",
                "title": "Python for  Data Science",
                "chapters": [],
                "practicals": [
                    {
                        "id": "practical-set-1---basics-of-python",
                        "title": "Practical Set 1 - Basics of Python ",
                        "content": "**1) Aim: Write a python program to create a simple arithmetic application\nincluding operations (addition, subtraction, multiplication, division,\nmodulus, exponent, integer division)** \n\n```python\na = int(input(\"Enter a number: \"))\nb = int(input(\"Enter a number: \"))\n\nprint(\"The value of arithmetic operations are\")\n\nadd = a + b\nprint(\"Addition is \", add)\n\nsub = a - b\nprint(\"Subtraction is \", sub)\n\nmul = a * b\nprint(\"Multiplication is \", mul)\n\ndiv = a / b\nprint(\"Division is \", div)\n\nmod = a % b\nprint(\"Modulus is \", mod)\n\nexp = a ** b\nprint(\"Exponent is \", exp)\n\nintdiv = a // b\nprint(\"Integer division is \", intdiv)\n\n```\n\n```output\nEnter a number: 10\nEnter a number: 3\nThe value of arithmetic operations are\nAddition is  13\nSubtraction is  7\nMultiplication is  30\nDivision is  3.3333333333333335\nModulus is  1\nExponent is  1000\nInteger division is  3\n\n```\n\n**2) Aim: Write a python program to convert numbers from octal, binary and hexadecimal systems into decimal number system** \n\n```python\na = input(\"Enter the value of binary: \")\nprint(\"The number in decimal is\", int(a, 2))\n\nb = input(\"Enter the value of octal: \")\nprint(\"The number in decimal is\", int(b, 8))\n\nc = input(\"Enter the value of hexadecimal: \")\nprint(\"The number in decimal is\", int(c, 16))\n\n```\n\n```output\nEnter the value of binary: 1010\nThe number in decimal is 10\nEnter the value of octal: 17\nThe number in decimal is 15\nEnter the value of hexadecimal: A\nThe number in decimal is 10\n\n```\n**3) Aim: Write a python program to convert numbers from decimal number system into octal, binary and hexadecimal system**\n\n```python\na = int(input(\"Enter the value of decimal: \"))\n\nprint(\"The number in binary is\", bin(a))\nprint(\"The number in octal is\", oct(a))\nprint(\"The number in hexadecimal is\", hex(a))\n\n```\n\n```output\nEnter the value of decimal: 25\nThe number in binary is 0b11001\nThe number in octal is 0o31\nThe number in hexadecimal is 0x19\n\n```\n**4) Aim: Write a python program to check whether the given number is a palindrome or not**\n\n```python\na = input(\"Enter the string: \")\n\nif a == a[::-1]:\n    print(\"It is a palindrome\")\nelse:\n    print(\"It is not a palindrome\")\n\n```\n\n```output\nEnter the string: 121\nIt is a palindrome\n\n```\n\n**5) Aim: Write a python program to calculate area of a triangle** \n\n```python\nbase = float(input(\"Enter the value of base: \"))\nheight = float(input(\"Enter the value of height: \"))\n\narea = (base * height) / 2\nprint(\"The area of triangle =\", area)\n\n```\n\n```output\nEnter the value of base: 10\nEnter the value of height: 5\nThe area of triangle = 25.0\n\n```\n**6) Aim: Write a python program to display maximum of given 3 numbers** \n\n```python\na = int(input(\"Enter the number: \"))\nb = int(input(\"Enter the number: \"))\nc = int(input(\"Enter the number: \"))\n\nif a > b and a > c:\n    print(\"The largest number is a :\", a)\nelif b > a and b > c:\n    print(\"The largest number is b :\", b)\nelse:\n    print(\"The largest number is c :\", c)\n\n```\n\n```output\nEnter the number: 10\nEnter the number: 25\nEnter the number: 15\nThe largest number is b : 25\n\n```\n**7) Aim: Write a python program to find those numbers which are divisible by 3 and multiple of 5 within 500 numbers** \n\n```python\na = int(input(\"Enter the number within 500: \"))\n\nfor i in range(1, a + 1):\n    if i % 5 == 0 and i % 3 == 0:\n        print(i)\n\n```\n\n```output\nEnter the number within 500: 100\n15\n30\n45\n60\n75\n90\n\n```\n**8) Aim: Write a python program to draw kite pattern using for loop** \n\n```python\na = int(input(\"Enter the size for pattern: \"))\n\nfor x in range(a, 0, -1):\n    print(\" \" * x, \"* \" * (a - x))\n\nfor x in range(0, a, 1):\n    print(\" \" * x, \"* \" * (a - x))\n\nfor x in range(a - 1, int(a / 2) - 1, -1):\n    print(\" \" * x, \"* \" * (a - x))\n\n```\n\n```output\nEnter the size for pattern: 5\n     *\n    * *\n   * * *\n  * * * *\n * * * * *\n  * * * *\n   * * *\n    * *\n     *\n\n```\n\n",
                        "locked": false
                    },
                    {
                        "id": "practical-set--02-looping-and-data-structure-with-python",
                        "title": "Practical Set 2- looping and data structure with python",
                        "content": "**1) Aim: Write a python program to print numbers from 1 to 50.\nFor multiple of 4 print name instead of number and for multiple of 5 print father\nnames for the numbers which are multiple of both 4 and 5 print surname.** \n\n```python\nfor i in range(1, 51):\n    if i % 4 == 0 and i % 5 == 0:\n        print(\"NoteXplain\")\n    elif i % 4 == 0:\n        print(\"NoteXplain\")\n    elif i % 5 == 0:\n        print(\"NoteXplain\")\n    else:\n        print(i)\n\n```\n\n```output\n1\n2\n3\nNoteXplain\nNoteXplain\n6\n7\nNoteXplain\n9\nNoteXplain\n11\nNoteXplain\n13\n14\nNoteXplain\n16\n17\nNoteXplain\n19\nNoteXplain\n21\n22\nNoteXplain\n24\nNoteXplain\n26\nNoteXplain\n28\n29\nNoteXplain\n31\n32\nNoteXplain\n34\nNoteXplain\n36\n37\nNoteXplain\n39\nNoteXplain\n41\n42\nNoteXplain\n44\nNoteXplain\n46\nNoteXplain\n48\n49\nNoteXplain\n\n```\n**2) Aim: Write a python program to find numbers between 500 and 800 when each digit of number is ODD and the number should be printed in sequence separated by comma.** \n\n```python\nitems = []\n\nfor i in range(500, 801):\n    s = str(i)\n    if (int(s[0]) % 2 != 0 and int(s[1]) % 2 != 0 and int(s[2]) % 2 != 0):\n        items.append(s)\n\nprint(\",\\n\".join(items))\n\n```\n\n```output\n511,\n513,\n515,\n517,\n519,\n531,\n533,\n535,\n537,\n539,\n551,\n553,\n555,\n557,\n559,\n571,\n573,\n575,\n577,\n579,\n591,\n593,\n595,\n597,\n599,\n711,\n713,\n715,\n717,\n719,\n731,\n733,\n735,\n737,\n739,\n751,\n753,\n755,\n757,\n759,\n771,\n773,\n775,\n777,\n779,\n791,\n793,\n795,\n797,\n799\n\n```\n**3) Aim: Write a python program which accepts a sequence of 4-digit binary numbers separated by comma and prints the numbers which are divisible by 3, separated by comma.** \n\n```python\nitems = []\n\nprint(\"Enter the 4-bit binary sequence separated by commas:\")\nnumbers = input().split(\",\")\n\nfor p in numbers:\n    x = int(p, 2)\n    if x % 3 == 0:\n        items.append(p)\n\nprint(\",\".join(items))\n\n```\n\n```output\nEnter the 4-bit binary sequence separated by commas:\n0100,0011,1010,1001,1111\n0011,1001,1111\n\n```\n**4) Aim: Write a python program to display Fibonacci sequence up to nth term using recursive functions.** \n\n```python\nn = int(input(\"Enter the number of terms: \"))\n\na, b = 0, 1\ncount = 0\n\nif n <= 0:\n    print(\"Please enter a positive integer.\")\nelif n == 1:\n    print(\"Fibonacci sequence:\")\n    print(a)\nelse:\n    print(\"Fibonacci sequence:\")\n    while count < n:\n        print(a, end=\" \")\n        a, b = b, a + b\n        count += 1\n\n```\n\n```output\nEnter the number of terms: 7\nFibonacci sequence:\n0 1 1 2 3 5 8\n\n```\n**5) Aim: Write a python program that accepts a string and calculates the number of uppercase and lowercase letters.** \n\n```python\ntext = input(\"Enter the string to check the lower and upper values:\\n\")\n\nlower_count = 0\nupper_count = 0\n\nfor char in text:\n    if 'a' <= char <= 'z':\n        lower_count += 1\n    elif 'A' <= char <= 'Z':\n        upper_count += 1\n\nprint(\"The lowercase values are :\", lower_count)\nprint(\"The uppercase values are :\", upper_count)\n\n```\n\n```output\nEnter the string to check the lower and upper values:\nNoteXplain Website\n\nThe lowercase values are : 13\nThe uppercase values are : 2\n\n```\n**6) Aim: Write a python program to search a number in array using sequential search.** \n\n```python\ndef sequential_search(arr, target):\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1\n\n# main program\narr = [10, 25, 30, 45, 65, 60, 70, 100]\ntarget = int(input(\"Enter the target value to search: \"))\n\nresult = sequential_search(arr, target)\n\nif result != -1:\n    print(\"Target value found at index :\", result)\nelse:\n    print(\"Target value not found in the array.\")\n\n```\n\n```output\nEnter the target value to search: 45\nTarget value found at index : 3\n\n```\n**7) Aim: Write a python program to sort elements of array.** \n\n```python\nsize = int(input(\"Enter the size of an array: \"))\n\narr = []\nfor i in range(size):\n    element = int(input(\"Enter the element: \"))\n    arr.append(element)\n\narr.sort()\n\nprint(\"Sorted array in ascending order is:\", arr)\nprint(\"Sorted array in descending order is:\", arr[::-1])\n\n```\n\n```output\nEnter the size of an array: 5\nEnter the element: 45\nEnter the element: 12\nEnter the element: 78\nEnter the element: 23\nEnter the element: 10\nSorted array in ascending order is: [10, 12, 23, 45, 78]\nSorted array in descending order is: [78, 45, 23, 12, 10]\n\n```\n**8) Aim: Write a python program to input two matrices and perform addition, subtraction, multiplication, and transpose operations.** \n\n```python\nimport numpy as np\n\narr1 = np.array([[1, 2, 3],\n                 [4, 5, 6],\n                 [7, 8, 9]])\n\narr2 = np.array([[3, 2, 1],\n                 [6, 5, 4],\n                 [9, 8, 7]])\n\nresult = np.zeros((3, 3), dtype=int)\n\nprint(\"The addition of matrix is:\\n\", arr1 + arr2)\nprint(\"The subtraction of matrix is:\\n\", arr1 - arr2)\n\nfor i in range(3):\n    for j in range(3):\n        for k in range(3):\n            result[i][j] += arr1[i][k] * arr2[k][j]\n\nprint(\"The multiplication of matrix is:\\n\", result)\n\nprint(\"The transpose of matrix 1 is:\\n\", arr1.T)\nprint(\"The transpose of matrix 2 is:\\n\", arr2.T)\n\n```\n\n```output\nThe addition of matrix is:\n [[ 4  4  4]\n  [10 10 10]\n  [16 16 16]]\n\nThe subtraction of matrix is:\n [[-2  0  2]\n  [-2  0  2]\n  [-2  0  2]]\n\nThe multiplication of matrix is:\n [[ 42  36  30]\n  [ 96  81  66]\n  [150 126 102]]\n\nThe transpose of matrix 1 is:\n [[1 4 7]\n  [2 5 8]\n  [3 6 9]]\n\nThe transpose of matrix 2 is:\n [[3 6 9]\n  [2 5 8]\n  [1 4 7]]\n\n```\n\n",
                        "locked": false
                    },
                    {
                        "id": "practical-set-3-to-study-the-use-of-numpy-and-pandas",
                        "title": "Practical Set 3- To study the use of NumPy and Pandas",
                        "content": "\n<mark>* Note:-\nThe data shown in this program/output is only for understanding and demonstration purposes.\nActual input data will be provided separately during execution or evaluation.</mark>\n \n**1) Do as directed:\na) Read student data from given excel file sheet named as “5CSE” into appropriate pandas data structure.** \n\n```python\nimport pandas as pd\n\ndf = pd.read_csv(\"5CSE.csv\", dtype={\"Enrollment\": int})\nprint(df)\n\n```\n\n```output\n   Enrollment        Name      Branch  Semester\n0   230490101   Student A        CSE         5\n1   230490102   Student B        CSE         5\n2   230490103   Student C        CSE         5\n3   230490104   Student D        CSE         5\n\n```\n\n**b) Aim: Fill missing values in columns “Subject” and “Batch” using forward fill method.** \n\n```python\nimport pandas as pd\n\ndf = pd.read_csv(\"5CSE.csv\")\n\ndf[\"Subject\"].fillna(method=\"ffill\", inplace=True)\ndf[\"Batch\"].fillna(method=\"ffill\", inplace=True)\n\nprint(df)\n\n```\n\n```output\n   Enrollment        Name   Subject        Batch  Branch  Semester\n0   230490101   Student A      PDS        Batch-A     CSE        5\n1   230490102   Student B      PDS        Batch-A     CSE        5\n2   230490103   Student C      PDS        Batch-A     CSE        5\n3   230490104   Student D      PDS        Batch-A     CSE        5\n\n```\n**c) Aim: Fill value “ABC” in “Mentor” column for students having “Enrollment” column value from “230490101” to “230490109” and “XYZ” for remaining students.** \n\n```python\ndef value(x):\n    if 230490101 <= x <= 230490109:\n        return \"ABC\"\n    else:\n        return \"XYZ\"\n\ndf[\"Mentor\"] = df.apply(lambda x: value(x[\"Enrollment\"]), axis=1)\nprint(df)\n\n```\n\n```output\n   Enrollment        Name   Subject    Batch  Branch  Semester Mentor\n0   230490101   Student A      PDS   Batch-A     CSE        5    ABC\n1   230490102   Student B      PDS   Batch-A     CSE        5    ABC\n2   230490103   Student C      PDS   Batch-A     CSE        5    ABC\n3   230490104   Student D      PDS   Batch-A     CSE        5    ABC\n4   230490110   Student E      PDS   Batch-A     CSE        5    XYZ\n\n```\n**d) Aim: Add a new column “City” in existing student data and fill that column with residential city of student.** \n\n```python\nimport pandas as pd\n\n# Assuming df is already loaded\ndf['City'] = [\n    \"Surat\", \"Bardoli\", \"Valsad\", \"Navsari\", \"Baroda\",\n    \"Navsari\", \"Baroda\", \"Surat\", \"Bardoli\", \"Valsad\"\n]\n\nprint(df)\n\n```\n\n```output\n   Enrollment        Name   Subject    Batch  Branch  Semester Mentor     City\n0   230490101   Student A      PDS   Batch-A     CSE        5    ABC    Surat\n1   230490102   Student B      PDS   Batch-A     CSE        5    ABC    Bardoli\n2   230490103   Student C      PDS   Batch-A     CSE        5    ABC    Valsad\n3   230490104   Student D      PDS   Batch-A     CSE        5    ABC    Navsari\n4   230490105   Student E      PDS   Batch-A     CSE        5    ABC    Baroda\n5   230490106   Student F      PDS   Batch-A     CSE        5    XYZ    Navsari\n6   230490107   Student G      PDS   Batch-A     CSE        5    XYZ    Baroda\n7   230490108   Student H      PDS   Batch-A     CSE        5    XYZ    Surat\n8   230490109   Student I      PDS   Batch-A     CSE        5    XYZ    Bardoli\n9   230490110   Student J      PDS   Batch-A     CSE        5    XYZ    Valsad\n\n```\n**e) Aim: Count total number of students subject-wise and batch-wise.** \n\n```python\n# Count batch-wise students\nbatch_count = df.groupby([\"Batch\"]).size().reset_index(name='number of students')\nprint(batch_count)\n\n# Count subject-wise students\nsubject_count = df.groupby([\"Subject\"]).size().reset_index(name='number of students')\nprint(subject_count)\n\n```\n\n```output\n      Batch  number of students\n0   Batch-A                  10\n\n   Subject  number of students\n0      PDS                  10\n\n```\n**2) Do as directed:\na) Read data from given csv file into appropriate pandas data structure and delete rows having missing values.** \n\n```python\nimport pandas as pd\nimport numpy as np\n\ndf = pd.read_csv(\"Automobile_data_Miss.csv\")\nprint(df)\n\ndf.dropna(axis='rows', inplace=True)\nprint(df)\n\n```\n\n```output\n   make fuel-type body-style  price\n0  toyota      gas      sedan  13495\n1  mazda       gas        NaN  16500\n2  honda       gas      sedan    NaN\n3  bmw         gas      sedan  36000\n4  audi        gas        NaN  42000\n\nAfter deleting rows with missing values:\n\n    make fuel-type body-style  price\n0  toyota      gas      sedan  13495\n3  bmw         gas      sedan  36000\n\n```\n\n**b) Aim: Calculate average price of cars having four and six cylinder engines.** \n\n```python\na1 = df[\"num-of-doors\"] == 'four'\na_1 = df[a1][\"price\"].mean()\n\na2 = df[\"num-of-doors\"] == 'two'\na_2 = df[a2][\"price\"].mean()\n\navg = (a_1 + a_2) / 2\n\nprint(\"Average price:\")\nprint(avg)\n\n```\n\n```output\nAverage price:\n21500.0\n\n```\n**c) Aim: Find out cheapest and most expensive car details.** \n\n```python\nprint(\"Detail of most expensive car:\")\nprint(df[df.price == df.price.max()])\n\nprint(\"\\nDetail of cheapest car:\")\nprint(df[df.price == df.price.min()])\n\n```\n\n```output\nDetail of most expensive car:\n\n    make   fuel-type  body-style   price\n3   BMW        gas       sedan     36000\n\n\nDetail of cheapest car:\n\n     make   fuel-type  body-style   price\n0   Toyota     gas       sedan     13495\n\n\n```\n**d) Aim: Find out convertible and sedan car details having maximum engine horsepower.** \n\n```python\ndf1 = df.loc[(df['body-style'] == 'convertible')]\ndf1 = df1.iloc[df1['horsepower'].argmax()]\n\ndf2 = df.loc[(df['body-style'] == 'sedan')]\ndf2 = df2.iloc[df2['horsepower'].argmax()]\n\nprint(\"Maximum horsepower of convertible car is:\\n\")\nprint(df1)\n\nprint(\"\\nMaximum horsepower of sedan car is:\\n\")\nprint(df2)\n\n```\n\n```output\nMaximum horsepower of convertible car is:\n\nmake              bmw\nfuel-type          gas\nbody-style   convertible\nhorsepower          262\nprice              42000\nName: 7, dtype: object\n\n\nMaximum horsepower of sedan car is:\n\nmake              audi\nfuel-type          gas\nbody-style        sedan\nhorsepower          240\nprice              36000\nName: 3, dtype: object\n\n```\n**e) Aim: Find average sedan car price.** \n\n```python\navg_price = df[df[\"body-style\"] == \"sedan\"].agg({\"price\": \"mean\"})\nprint(avg_price)\n\n```\n\n```output\n       price\n0   24747.5\n\n```\n**f) Aim: Count total number of cars per company.** \n\n```python\nimport pandas as pd\n\ndf = pd.read_csv(\"Automobile_data_Miss.csv\")\n\ncar_counts = df[\"make\"].value_counts()\nprint(car_counts)\n\n```\n\n```output\nmake\nbmw        2\ntoyota    1\nmazda     1\nhonda     1\naudi      1\nName: count, dtype: int64\n\n```\n**g) Aim: Find each company’s highest car price.**\n\n```python\nimport pandas as pd\n\ndf = pd.read_csv(\"Automobile_data_Miss.csv\")\n\ncar_companies = df.groupby(\"make\")\nhighest_price = car_companies[\"price\"].max()\n\nprint(highest_price)\n\n```\n\n```output\nmake\naudi      42000\nbmw       36000\nhonda     16500\nmazda     16500\ntoyota   13495\nName: price, dtype: int64\n\n```\n \n"
                    },
                    {
                        "id": "practical-set-4",
                        "title": "Practical Set 4- Use of matplotlib and pandas Libraries for Data Analysis and Visualization.",
                        "content": "<mark>*Note:-\nThe displayed data is only for understanding and demonstration purposes.\nActual data will be provided at the time of program execution.</mark> \n\n\n<mark>Aim: Use of matplotlib and pandas Libraries for Data Analysis and\nVisualization.</mark> \n\n**1) Plot gender-wise share of overall voters with legend and suitable labels.\n(Pie chart).** \n\n```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Sample data created inside code (works online)\ndata = {\n    \"Gender\": [\"Female\", \"Male\", \"Other\"],\n    \"Voters\": [485000, 515000, 5000]\n}\n\n# Create DataFrame\ndf = pd.DataFrame(data)\n\n# Values for pie chart\nsizes = df[\"Voters\"]\nlabels = df[\"Gender\"]\ncolors = [\"palegreen\", \"lightskyblue\", \"lightcoral\"]\n\n# Plot pie chart\nplt.figure(figsize=(6, 6))\nplt.pie(\n    sizes,\n    labels=labels,\n    colors=colors,\n    startangle=90,\n    autopct=\"%.1f%%\",\n    shadow=True\n)\nplt.title(\"Gender-wise Share of Overall Voters\")\nplt.legend(labels, loc=\"best\")\nplt.show()\n\n```\n\n```output\nSum of Female voters =  485000\nSum of Male voters =  515000\nSum of Other voters =  5000\n\nA pie chart is displayed showing the gender-wise share of overall voters\nwith proper labels and legend.\n\n```\n\n![Gender Distribution](/images/gender-distribution.png)\n\n--------------------------------------------------------------------------------------------\n**2) Aim: Indian states are divided into six administrative zones: Central, East, North, North East, South and Western.Plot six bar chart into single figure to visualize total voters with suitable chart title.** \n\n```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Sample data created inside code (works online)\ndata = {\n    \"State\": [\n        \"State1\",\"State2\",\"State3\",\"State4\",\"State5\",\"State6\",\n        \"State7\",\"State8\",\"State9\",\"State10\",\"State11\",\"State12\"\n    ],\n    \"Total Voters\": [\n        450000, 520000, 300000, 280000, 410000, 390000,\n        360000, 470000, 500000, 330000, 290000, 440000\n    ],\n    \"Zone\": [\n        \"Southern\",\"Southern\",\"North East\",\"East\",\"North\",\"Central\",\n        \"Western\",\"Western\",\"North\",\"East\",\"North East\",\"Central\"\n    ]\n}\n\n# Create DataFrame\nresult_df = pd.DataFrame(data)\n\n# Group by Zone and calculate total voters\nzone_voters = result_df.groupby(\"Zone\")[\"Total Voters\"].sum()\n\n# Plot bar chart\nplt.figure(figsize=(10, 6))\nplt.bar(zone_voters.index, zone_voters.values, color=\"skyblue\")\nplt.title(\"Total Voters vs Administrative Zones\")\nplt.xlabel(\"Administrative Zones\")\nplt.ylabel(\"Total Voters\")\nplt.show()\n\n```\n\n```output\nA bar chart is displayed in a single figure showing Total Voters\non the Y-axis and Administrative Zones (Central, East, North,\nNorth East, South, Western) on the X-axis with a suitable title.\n\n```\n\n![Indian states are divided into six administrative zones](/images/indian-states-zones.png)\n\n--------------------------------------------------------------------------------------------\n**3) Aim: Plot zone-wise share of total voters with legend and suitable labels (Pie chart).** \n\n```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Sample data created inside code (works online)\ndata = {\n    \"Zone\": [\"Central\", \"East\", \"North\", \"North East\", \"Southern\", \"Western\"],\n    \"Total Voters\": [320000, 410000, 450000, 280000, 500000, 390000]\n}\n\n# Create DataFrame\ndf = pd.DataFrame(data)\n\n# Values for pie chart\nsizes = df[\"Total Voters\"]\nlabels = df[\"Zone\"]\ncolors = [\"gold\", \"lightskyblue\", \"lightgreen\", \"violet\", \"orange\", \"lightcoral\"]\n\n# Plot pie chart\nplt.figure(figsize=(7, 7))\nplt.pie(\n    sizes,\n    labels=labels,\n    colors=colors,\n    startangle=90,\n    autopct=\"%.1f%%\",\n    shadow=True\n)\nplt.title(\"Zone-wise Share of Total Voters\")\nplt.legend(labels, loc=\"best\")\nplt.show()\n\n```\n\n```output\nA pie chart is displayed showing the zone-wise share of total voters\n(Central, East, North, North East, Southern, Western) with suitable labels\nand legend.\n\n```\n![Zones voter distribution analysis](/images/zones-voter-analysis.png)\n\n--------------------------------------------------------------------------------------------\n**4) Aim: Plot horizontal bar chart for states vs total actual votes with suitable labels.**\n\n```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Sample data created inside code (works online)\ndata = {\n    \"State Name\": [\n        \"Gujarat\", \"Maharashtra\", \"Rajasthan\",\n        \"Madhya Pradesh\", \"Uttar Pradesh\", \"Karnataka\"\n    ],\n    \"Total Actual Votes\": [\n        420000, 610000, 380000, 450000, 700000, 520000\n    ]\n}\n\n# Create DataFrame\nresult_df = pd.DataFrame(data)\n\n# Plot horizontal bar chart\nplt.figure(figsize=(8, 5))\nplt.barh(\n    y=result_df['State Name'],\n    width=result_df['Total Actual Votes'],\n    color=\"skyblue\"\n)\n\nplt.title(\"States vs Total Actual Voters\")\nplt.ylabel(\"State Name\")\nplt.xlabel(\"Total Actual Voters\")\nplt.show()\n```\n\n\n```output\nA horizontal bar chart is displayed showing States on the Y-axis\nand Total Actual Votes on the X-axis with suitable labels and title.\n\n```\n\n![State vs Actual Voters](/images/state-vs-actual-voters.png)\n\n--------------------------------------------------------------------------------------------\n **5) Plot type-wise share (EVM and Postal) with legend and suitable labels\nfor each administrative zoneinto single figure. (Pie chart).** \n\n```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Sample data created inside code (works online)\ndata = {\n    \"Zone\": [\"Central\", \"East\", \"North\", \"North East\", \"Southern\", \"Western\"],\n    \"EVM Votes\": [280000, 350000, 400000, 220000, 450000, 330000],\n    \"Postal Votes\": [40000, 60000, 50000, 30000, 50000, 40000]\n}\n\n# Create DataFrame\ndf = pd.DataFrame(data)\n\n# Create subplots (single figure with multiple pie charts)\nfig, axes = plt.subplots(2, 3, figsize=(12, 8))\naxes = axes.flatten()\n\nfor i, zone in enumerate(df[\"Zone\"]):\n    sizes = [\n        df.loc[i, \"EVM Votes\"],\n        df.loc[i, \"Postal Votes\"]\n    ]\n    labels = [\"EVM Votes\", \"Postal Votes\"]\n    colors = [\"lightskyblue\", \"lightcoral\"]\n\n    axes[i].pie(\n        sizes,\n        labels=labels,\n        autopct=\"%.1f%%\",\n        startangle=90,\n        colors=colors\n    )\n    axes[i].set_title(zone)\n\nplt.suptitle(\"Type-wise Share of Votes (EVM vs Postal) by Administrative Zone\")\nplt.tight_layout()\nplt.show()\n\n\n```\n\n```output\nA single figure is displayed containing multiple pie charts.\nEach pie chart shows the type-wise share of votes (EVM and Postal)\nfor each administrative zone with suitable labels and legend.\n\n```\n\n![EVM-VS-POSTAL](/images/EVM-VS-POSTAL.png)\n\n--------------------------------------------------------------------------------------------\n**6) Plot vote deficits (Total actual votes – Total voters) for each states using\nline chart.** \n\n```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Sample data created inside code (works online)\ndata = {\n    \"State\": [\n        \"Gujarat\", \"Maharashtra\", \"Rajasthan\",\n        \"Madhya Pradesh\", \"Uttar Pradesh\", \"Karnataka\"\n    ],\n    \"Total Voters\": [\n        500000, 700000, 420000, 480000, 800000, 600000\n    ],\n    \"Total Actual Votes\": [\n        420000, 610000, 380000, 450000, 700000, 520000\n    ]\n}\n\n# Create DataFrame\ndf = pd.DataFrame(data)\n\n# Calculate vote deficit\ndf[\"Vote Deficit\"] = df[\"Total Voters\"] - df[\"Total Actual Votes\"]\n\n# Plot line chart\nplt.figure(figsize=(9, 5))\nplt.plot(\n    df[\"State\"],\n    df[\"Vote Deficit\"],\n    marker=\"o\",\n    linestyle=\"-\",\n    color=\"red\"\n)\n\nplt.title(\"Vote Deficit by State\")\nplt.xlabel(\"State\")\nplt.ylabel(\"Vote Deficit (Total Voters - Total Actual Votes)\")\nplt.grid(True)\nplt.show()\n\n```\n\n```output\nA line chart is displayed showing vote deficit for each state.\nStates are shown on the X-axis and Vote Deficit on the Y-axis,\nclearly representing the difference between Total Voters and\nTotal Actual Votes.\n\n```\n\n![vote-deficit-by-state](/images/vote-deficit-by-state.png)\n\n--------------------------------------------------------------------------------------------\n**7) Aim: Plot horizontal bar chart for states vs male, female and others votes (grouping of bars) with legend and suitable title.** \n\n```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Sample data created inside code (works online)\ndata = {\n    \"State\": [\"Gujarat\", \"Maharashtra\", \"Rajasthan\", \"Karnataka\", \"Uttar Pradesh\"],\n    \"Male\": [220000, 300000, 180000, 260000, 350000],\n    \"Female\": [200000, 280000, 170000, 240000, 330000],\n    \"Other\": [5000, 6000, 4000, 5000, 7000]\n}\n\n# Create DataFrame\ndf = pd.DataFrame(data)\n\n# Positions for bars\ny = np.arange(len(df[\"State\"]))\nbar_width = 0.25\n\n# Plot grouped horizontal bar chart\nplt.figure(figsize=(10, 6))\nplt.barh(y - bar_width, df[\"Male\"], height=bar_width, label=\"Male\", color=\"lightskyblue\")\nplt.barh(y, df[\"Female\"], height=bar_width, label=\"Female\", color=\"palegreen\")\nplt.barh(y + bar_width, df[\"Other\"], height=bar_width, label=\"Other\", color=\"lightcoral\")\n\n# Labels and title\nplt.yticks(y, df[\"State\"])\nplt.xlabel(\"Number of Votes\")\nplt.ylabel(\"States\")\nplt.title(\"State-wise Votes by Gender\")\nplt.legend()\n\nplt.show()\n\n```\n\n```output\nA grouped horizontal bar chart is displayed showing state-wise\nMale, Female, and Other votes with different colored bars,\nproper legend, and suitable chart title.\n\n```\n\n![state-wise-voters-by-gender](/images/state-wise-voters-by-gender.png)\n\n\n"
                    },
                    {
                        "id": "practical-5---to-study-the-sklearn-library-and-performvariousstatistics",
                        "title": "Practical Set 5 - To study the sklearn Library and performvariousstatistics",
                        "content": "**1) Load iris dataset from sklearn library given iris.csv file into appropriatedatastructure of pandas.** \n\n```python\nimport pandas as pd\nfrom sklearn.datasets import load_iris\n\n# Load iris dataset from sklearn\niris = load_iris()\n\n# Create pandas DataFrame\ndf = pd.DataFrame(\n    data=iris.data,\n    columns=iris.feature_names\n)\n\n# Add target column\ndf[\"target\"] = iris.target\n\nprint(df.head())\n\n```\n\n```output\n   sepal length (cm)  sepal width (cm)  petal length (cm)  petal width (cm)  target\n0                5.1               3.5                1.4               0.2       0\n1                4.9               3.0                1.4               0.2       0\n2                4.7               3.2                1.3               0.2       0\n3                4.6               3.1                1.5               0.2       0\n4                5.0               3.6                1.4               0.2       0\n\n```\n\n---------------------------------------------------------------------------------------------------------------\n**2) Aim: Perform Descriptive Statistics for Numeric Data, measuring central tendency, variance, and range.**\n\n```python\nimport pandas as pd\nfrom sklearn.datasets import load_iris\n\n# Load iris dataset\niris = load_iris()\n\n# Create DataFrame\ndf = pd.DataFrame(iris.data, columns=iris.feature_names)\n\n# Central Tendency\nprint(\"Mean:\\n\", df.mean())\nprint(\"\\nMedian:\\n\", df.median())\nprint(\"\\nMode:\\n\", df.mode().iloc[0])\n\n# Variance and Standard Deviation\nprint(\"\\nVariance:\\n\", df.var())\nprint(\"\\nStandard Deviation:\\n\", df.std())\n\n# Range (max - min)\nrange_values = df.max() - df.min()\nprint(\"\\nRange:\\n\", range_values)\n\n```\n \n```output\nMean:\nsepal length (cm)    5.843333\nsepal width (cm)     3.057333\npetal length (cm)    3.758000\npetal width (cm)     1.199333\ndtype: float64\n\nMedian:\nsepal length (cm)    5.80\nsepal width (cm)     3.00\npetal length (cm)    4.35\npetal width (cm)     1.30\ndtype: float64\n\nMode:\nsepal length (cm)    5.0\nsepal width (cm)     3.0\npetal length (cm)    1.5\npetal width (cm)     0.2\nName: 0, dtype: float64\n\nVariance:\nsepal length (cm)    0.685694\nsepal width (cm)     0.189979\npetal length (cm)    3.116278\npetal width (cm)     0.581006\ndtype: float64\n\nStandard Deviation:\nsepal length (cm)    0.828066\nsepal width (cm)     0.435866\npetal length (cm)    1.765298\npetal width (cm)     0.762238\ndtype: float64\n\nRange:\nsepal length (cm)    3.6\nsepal width (cm)     2.4\npetal length (cm)    5.9\npetal width (cm)     2.4\ndtype: float64\n\n```\n\n---------------------------------------------------------------------------------------------------------------\n**3) To Working with percentiles and defining measures of normality.**\n\n```python\nimport pandas as pd\nfrom sklearn.datasets import load_iris\nfrom scipy.stats import skew, kurtosis\n\n# Load iris dataset\niris = load_iris()\n\n# Create DataFrame\ndf = pd.DataFrame(iris.data, columns=iris.feature_names)\n\n# Percentiles\nprint(\"25th Percentile:\\n\", df.quantile(0.25))\nprint(\"\\n50th Percentile (Median):\\n\", df.quantile(0.50))\nprint(\"\\n75th Percentile:\\n\", df.quantile(0.75))\n\n# Measures of normality\nprint(\"\\nSkewness:\\n\", df.apply(skew))\nprint(\"\\nKurtosis:\\n\", df.apply(kurtosis))\n\n```\n\n```output\n25th Percentile:\nsepal length (cm)    5.1\nsepal width (cm)     2.8\npetal length (cm)    1.6\npetal width (cm)     0.3\nName: 0.25, dtype: float64\n\n50th Percentile (Median):\nsepal length (cm)    5.8\nsepal width (cm)     3.0\npetal length (cm)    4.35\npetal width (cm)     1.3\nName: 0.5, dtype: float64\n\n75th Percentile:\nsepal length (cm)    6.4\nsepal width (cm)     3.3\npetal length (cm)    5.1\npetal width (cm)     1.8\nName: 0.75, dtype: float64\n\nSkewness:\nsepal length (cm)    0.314911\nsepal width (cm)     0.334053\npetal length (cm)   -0.274884\npetal width (cm)    -0.102967\ndtype: float64\n\nKurtosis:\nsepal length (cm)   -0.552064\nsepal width (cm)     0.228249\npetal length (cm)   -1.402103\npetal width (cm)    -1.358704\ndtype: float64\n\n```\n\n---------------------------------------------------------------------------------------------------------------\n**4) Aim: To count categorical data, understand frequencies, and create contingency tables.** \n\n```python\nimport pandas as pd\nfrom sklearn.datasets import load_iris\n\n# Load iris dataset\niris = load_iris()\n\n# Create DataFrame\ndf = pd.DataFrame(iris.data, columns=iris.feature_names)\n\n# Add categorical column (species)\ndf[\"species\"] = iris.target\ndf[\"species\"] = df[\"species\"].map({\n    0: \"Setosa\",\n    1: \"Versicolor\",\n    2: \"Virginica\"\n})\n\n# Counting frequency of categorical data\nprint(\"Frequency of each species:\")\nprint(df[\"species\"].value_counts())\n\n# Create contingency table (species vs sepal length category)\ndf[\"sepal_length_category\"] = pd.cut(\n    df[\"sepal length (cm)\"],\n    bins=[4, 5.5, 7.5],\n    labels=[\"Short\", \"Long\"]\n)\n\ncontingency_table = pd.crosstab(\n    df[\"species\"],\n    df[\"sepal_length_category\"]\n)\n\nprint(\"\\nContingency Table (Species vs Sepal Length Category):\")\nprint(contingency_table)\n\n```\n\n```output\nFrequency of each species:\nSetosa        50\nVersicolor    50\nVirginica     50\nName: species, dtype: int64\n\nContingency Table (Species vs Sepal Length Category):\nsepal_length_category  Short  Long\nspecies                            \nSetosa                    45     5\nVersicolor                18    32\nVirginica                  2    48\n\n```\n\n---------------------------------------------------------------------------------------------------------------\n**5) To Creating Applied Visualization for EDA like boxplots.** \n```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn.datasets import load_iris\n\n# Load iris dataset\niris = load_iris()\n\n# Create DataFrame\ndf = pd.DataFrame(iris.data, columns=iris.feature_names)\n\n# Create boxplots for numeric features\nplt.figure(figsize=(10, 6))\ndf.boxplot()\nplt.title(\"Boxplot for Iris Dataset Features\")\nplt.xlabel(\"Features\")\nplt.ylabel(\"Values\")\nplt.xticks(rotation=45)\nplt.show()\n\n```\n\n```output\nA boxplot is displayed showing the distribution of iris dataset features.\nEach box represents the spread, median, and presence of outliers for\nsepal length, sepal width, petal length, and petal width.\n\n```\n\n![boxplot-for-iris-dataset-features](/images/boxplot-for-iris-dataset-features.png)\n"
                    },
                    {
                        "id": "practical-set-6----create-various-plots-using-matplotlib-library",
                        "title": "Practical Set 6 -  Create various plots using matplotlib library.",
                        "content": "**1) Prepare a Pie charts by taking suitable data as reference.** \n\n```python\nimport matplotlib.pyplot as plt\n\n# Sample data (works online & offline)\nlabels = [\"Python\", \"Java\", \"C++\", \"Other\"]\nsizes = [40, 30, 20, 10]\ncolors = [\"gold\", \"lightskyblue\", \"lightgreen\", \"lightcoral\"]\n\n# Plot pie chart\nplt.figure(figsize=(6, 6))\nplt.pie(\n    sizes,\n    labels=labels,\n    colors=colors,\n    autopct=\"%.1f%%\",\n    startangle=90,\n    shadow=True\n)\nplt.title(\"Programming Language Usage\")\nplt.legend(labels, loc=\"best\")\nplt.show()\n```\n\n```output\nA pie chart is displayed showing the percentage distribution of\nprogramming language usage with suitable labels and legend.\n\n```\n\n![programming-language-usage](/images/programming-language-usage)\n\n---------------------------------------------------------------------------------------------------------------\n**2) Prepare a Bar charts by taking suitable data as reference** \n\n```python\nimport matplotlib.pyplot as plt\n\n# Sample data (works online & offline)\nsubjects = [\"PDS\", \"ADA\", \"DBMS\", \"CN\", \"OS\"]\nmarks = [78, 85, 72, 80, 75]\n\n# Plot bar chart\nplt.figure(figsize=(8, 5))\nplt.bar(subjects, marks, color=\"skyblue\")\nplt.title(\"Marks Obtained in Different Subjects\")\nplt.xlabel(\"Subjects\")\nplt.ylabel(\"Marks\")\nplt.show()\n\n```\n\n```output\nA bar chart is displayed showing subjects on the X-axis\nand marks on the Y-axis with a suitable title and labels.\n\n```\n\n![marks-obtained-in-different-subjects](/images/marks-obtained-in-different-subjects.png)\n\n\n---------------------------------------------------------------------------------------------------------------\n**3) Aim: Prepare a Histogram by taking suitable data as reference.** \n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Generate random data\nx = 20 * np.random.randn(10000)\n\n# Plot histogram\nplt.hist(\n    x,\n    bins=25,\n    range=(-50, 50),\n    histtype='stepfilled',\n    align='mid',\n    color='green',\n    label='Test Data'\n)\n\nplt.title('Step Filled Histogram')\nplt.xlabel('Value Range')\nplt.ylabel('Frequency')\nplt.legend()\nplt.show()\n\n```\n\n```output\nA step-filled histogram is displayed showing the frequency distribution\nof randomly generated data. The histogram clearly represents how values\nare spread across the specified range with proper labels and legend.\n\n```\n\n![step-filled-histogram](/images/step-filled-histogram.png)\n\n\n\n"
                    }
                ]
            },
            {
                "id": "analysis-and-design-of-algorithms",
                "title": "Analysis And Design Of Algorithms",
                "chapters": [],
                "practicals": [
                    {
                        "id": "aim--implementation-and-time-analysis-of-sorting-algorithms",
                        "title": "Practical 1",
                        "content": "**Aim-Implementation and time analysis of Sorting Algorithm.**\n\n\n<mark>1 Bubble Sort </mark> \n\n```c \n\n#include <stdio.h>\n\nvoid bubblesort(int arr[], int n)\n{\n    int i, j, temp;\n\n    for (i = 0; i < n - 1; i++)\n    {\n        for (j = 0; j < n - i - 1; j++)\n        {\n            if (arr[j] > arr[j + 1])\n            {\n                temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main()\n{\n    int arr[] = {5, 8, 1, 2, 6, 4};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int i;\n\n    printf(\"This is the program for bubble sort.\\n\\n\");\n\n    printf(\"Original Array : \");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n\n    bubblesort(arr, n);\n\n    printf(\"\\nSorted Array : \");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n\n    return 0;\n}\n\n```\n\n```output\nThis is the program for bubble sort.\n\nOriginal Array : 5 8 1 2 6 4\nSorted Array : 1 2 4 5 6 8\n```\n\n\n\n\n<mark>2 Selection Sort </mark> \n\n```c\n#include <stdio.h>\n\n// Function to perform Selection Sort\nvoid selectionSort(int arr[], int n)\n{\n    int i, j, min_index, temp;\n\n    for (i = 0; i < n - 1; i++)\n    {\n        min_index = i;\n\n        for (j = i + 1; j < n; j++)\n        {\n            if (arr[j] < arr[min_index])\n            {\n                min_index = j;\n            }\n        }\n\n        if (min_index != i)\n        {\n            temp = arr[i];\n            arr[i] = arr[min_index];\n            arr[min_index] = temp;\n        }\n    }\n}\n\n// Function to print array\nvoid printArray(int arr[], int n)\n{\n    int i;\n    for (i = 0; i < n; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main()\n{\n    int arr[] = {92, 3, 45, 2, 67};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    printf(\"This is the program for Selection Sort.\\n\\n\");\n\n    printf(\"Original array : \");\n    printArray(arr, n);\n\n    selectionSort(arr, n);\n\n    printf(\"Sorted array   : \");\n    printArray(arr, n);\n\n    return 0;\n}\n\n```\n \n```output\nThis is the program for Selection Sort.\n\nOriginal array : 92 3 45 2 67\nSorted array   : 2 3 45 67 92\n\n```\n\n\n\n<mark>3. Merge Sort </mark> \n\n```c\n#include <stdio.h>\n\n// Function to merge two subarrays\nvoid merge(int arr[], int left, int mid, int right)\n{\n    int i, j, k;\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n\n    int L[n1], R[n2];\n\n    for (i = 0; i < n1; i++)\n        L[i] = arr[left + i];\n\n    for (j = 0; j < n2; j++)\n        R[j] = arr[mid + 1 + j];\n\n    i = 0;\n    j = 0;\n    k = left;\n\n    while (i < n1 && j < n2)\n    {\n        if (L[i] <= R[j])\n        {\n            arr[k] = L[i];\n            i++;\n        }\n        else\n        {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    while (i < n1)\n    {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    while (j < n2)\n    {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\n// Function to perform Merge Sort\nvoid mergeSort(int arr[], int left, int right)\n{\n    if (left < right)\n    {\n        int mid = (left + right) / 2;\n\n        mergeSort(arr, left, mid);\n        mergeSort(arr, mid + 1, right);\n        merge(arr, left, mid, right);\n    }\n}\n\n// Function to print array\nvoid printArray(int arr[], int size)\n{\n    int i;\n    for (i = 0; i < size; i++)\n        printf(\"%d \", arr[i]);\n\n    printf(\"\\n\");\n}\n\nint main()\n{\n    int arr[] = {38, 27, 43, 3, 9, 82, 10};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    printf(\"This is the program for Merge Sort.\\n\\n\");\n\n    printf(\"Original array : \");\n    printArray(arr, n);\n\n    mergeSort(arr, 0, n - 1);\n\n    printf(\"Sorted array   : \");\n    printArray(arr, n);\n\n    return 0;\n}\n\n```\n\n```output\nThis is the program for Merge Sort.\n\nOriginal array : 38 27 43 3 9 82 10\nSorted array   : 3 9 10 27 38 43 82\n\n```\n\n\n<mark>Insertion Sort </mark> \n```c\n#include <stdio.h>\n\n// Function to print array\nvoid printArray(int arr[], int n)\n{\n    int i;\n    for (i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\n\n// Function to perform Insertion Sort\nvoid insertionSort(int arr[], int n)\n{\n    int i, key, j, step = 1;\n\n    for (i = 1; i < n; i++)\n    {\n        key = arr[i];\n        j = i - 1;\n\n        while (j >= 0 && arr[j] > key)\n        {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n\n        arr[j + 1] = key;\n\n        printf(\"Step %d: \", step++);\n        printArray(arr, n);\n    }\n}\n\nint main()\n{\n    int arr[] = {12, 11, 13, 5, 6};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    printf(\"This is the program for Insertion Sort.\\n\\n\");\n\n    printf(\"Original array : \");\n    printArray(arr, n);\n\n    insertionSort(arr, n);\n\n    printf(\"Sorted array   : \");\n    printArray(arr, n);\n\n    return 0;\n}\n\n```\n\n```output\nThis is the program for Insertion Sort.\n\nOriginal array : 12 11 13 5 6\nStep 1: 11 12 13 5 6\nStep 2: 11 12 13 5 6\nStep 3: 5 11 12 13 6\nStep 4: 5 6 11 12 13\nSorted array   : 5 6 11 12 13\n\n```\n\n\n\n\n\n\n<mark>Quick Sort</mark> \n```c\n#include <stdio.h>\n\n// Function to print array\nvoid printArray(int arr[], int n)\n{\n    int i;\n    for (i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\n\n// Function to partition the array\nint partition(int arr[], int low, int high)\n{\n    int pivot = arr[high];\n    int i = low - 1;\n    int temp, j;\n\n    for (j = low; j < high; j++)\n    {\n        if (arr[j] < pivot)\n        {\n            i++;\n            temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n\n    temp = arr[i + 1];\n    arr[i + 1] = arr[high];\n    arr[high] = temp;\n\n    return i + 1;\n}\n\n// Function to perform Quick Sort\nvoid quickSort(int arr[], int low, int high)\n{\n    if (low < high)\n    {\n        int pi = partition(arr, low, high);\n\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nint main()\n{\n    int arr[] = {10, 7, 8, 9, 1, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    printf(\"This is the program for Quick Sort.\\n\\n\");\n\n    printf(\"Original array : \");\n    printArray(arr, n);\n\n    quickSort(arr, 0, n - 1);\n\n    printf(\"Sorted array   : \");\n    printArray(arr, n);\n\n    return 0;\n}\n\n```\n\n```output\nThis is the program for Quick Sort.\n\nOriginal array : 10 7 8 9 1 5\nSorted array   : 1 5 7 8 9 10\n\n```\n\n\n<mark>Time Complexity Table</mark> \n| Sorting Algorithm | Bubble Sort | Selection Sort | Insertion Sort | Merge Sort | Quick Sort |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| **Worst Case** | O(n²) | O(n²) | O(n²) | O(n log n) | O(n²) |\n| **Best Case** | O(n) | O(n²) | O(n) | O(n log n) | O(n log n) |\n| **Average Case** | O(n²) | O(n²) | O(n²) | O(n log n) | O(n log n) |\n\n\n\n\n\n"
                    },
                    {
                        "id": "practical-2",
                        "title": "Practical 2",
                        "content": "\n**Aim-Implementation and Time Analysis of Linear Search and Binary Search Algorithm**\n\n<mark>A. Linear Search</mark> \n```c\n#include <stdio.h>\n\nint main()\n{\n    int n, i, search, found = 0;\n\n    printf(\"Enter the size of Array : \");\n    scanf(\"%d\", &n);\n\n    int arr[n];\n\n    printf(\"\\nEnter the elements of Array:\\n\");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"Element %d : \", i + 1);\n        scanf(\"%d\", &arr[i]);\n    }\n\n    printf(\"\\nWhich element you want to find : \");\n    scanf(\"%d\", &search);\n\n    for (i = 0; i < n; i++)\n    {\n        if (search == arr[i])\n        {\n            printf(\"\\nThe element %d found at index : %d\", search, i);\n            found = 1;\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        printf(\"\\nThe element %d is not found\", search);\n    }\n\n    return 0;\n}\n\n```\n```output\nEnter the size of Array : 5\n\nEnter the elements of Array:\nElement 1 : 10\nElement 2 : 20\nElement 3 : 30\nElement 4 : 40\nElement 5 : 50\n\nWhich element you want to find : 30\n\nThe element 30 found at index : 2\n\n```\n\n\n\n\n\n<mark>B. Binary Search</mark> \n\n **Note: Binary Search works only on sorted arrays** \n```c\n#include <stdio.h>\n\n// Function to perform Binary Search\nint binarySearch(int arr[], int size, int target)\n{\n    int low = 0;\n    int high = size - 1;\n\n    while (low <= high)\n    {\n        int mid = (low + high) / 2;\n\n        if (arr[mid] == target)\n            return mid;\n        else if (arr[mid] < target)\n            low = mid + 1;\n        else\n            high = mid - 1;\n    }\n\n    return -1;\n}\n\nint main()\n{\n    int n, i, target, result;\n\n    printf(\"Enter the size of Array : \");\n    scanf(\"%d\", &n);\n\n    int arr[n];\n\n    printf(\"\\nEnter elements of Array (in sorted order):\\n\");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"Element %d : \", i + 1);\n        scanf(\"%d\", &arr[i]);\n    }\n\n    printf(\"\\nWhich element you want to find : \");\n    scanf(\"%d\", &target);\n\n    result = binarySearch(arr, n, target);\n\n    if (result != -1)\n        printf(\"\\nThe element %d found at index : %d\", target, result);\n    else\n        printf(\"\\nThe element %d is not found\", target);\n\n    return 0;\n}\n\n```\n```output\nEnter the size of Array : 5\n\nEnter elements of Array (in sorted order):\nElement 1 : 10\nElement 2 : 20\nElement 3 : 30\nElement 4 : 40\nElement 5 : 50\n\nWhich element you want to find : 40\n\nThe element 40 found at index : 3\n\n```\n\n\n<mark>Time Complexity Table</mark> \n| Search Algorithm | Linear Search | Binary Search |\n| :--- | :--- | :--- |\n| **Worst Case** | O(n) | O(log n) |\n| **Best Case** | O(1) | O(1) |\n| **Average Case** | O(n) | O(log n) |\n"
                    },
                    {
                        "id": "practical-3",
                        "title": "Practical 3",
                        "content": "**Aim : Implementation of max-heap sort algorithm.** \n\n```c\n#include <stdio.h>\n\n// Function to swap two elements\nvoid swap(int *a, int *b)\n{\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\n// Function to heapify a subtree rooted at index i\nvoid heapify(int arr[], int n, int i)\n{\n    int largest = i;\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;\n\n    if (left < n && arr[left] > arr[largest])\n        largest = left;\n\n    if (right < n && arr[right] > arr[largest])\n        largest = right;\n\n    if (largest != i)\n    {\n        swap(&arr[i], &arr[largest]);\n        heapify(arr, n, largest);\n    }\n}\n\n// Function to perform Heap Sort\nvoid heapSort(int arr[], int n)\n{\n    int i;\n\n    // Build Max Heap\n    for (i = n / 2 - 1; i >= 0; i--)\n        heapify(arr, n, i);\n\n    // Extract elements from heap\n    for (i = n - 1; i > 0; i--)\n    {\n        swap(&arr[0], &arr[i]);\n        heapify(arr, i, 0);\n    }\n}\n\n// Function to print array\nvoid printArray(int arr[], int n)\n{\n    int i;\n    for (i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\n\nint main()\n{\n    int arr[] = {4, 10, 3, 5, 1};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    printf(\"This is the program for Max Heap Sort.\\n\\n\");\n\n    printf(\"Original array : \");\n    printArray(arr, n);\n\n    heapSort(arr, n);\n\n    printf(\"Sorted array   : \");\n    printArray(arr, n);\n\n    return 0;\n}\n\n```\n```output\nThis is the program for Max Heap Sort.\n\nOriginal array : 4 10 3 5 1\nSorted array   : 1 3 4 5 10\n\n```\n\n<mark>Time Complexity Table</mark> \n| Sorting Algorithm | Max Heap Sort |\n| :--- | :--- |\n| **Worst Case** | O(n log n) |\n| **Best Case** | O(n log n) |\n| **Average Case** | O(n log n) |\n"
                    },
                    {
                        "id": "practical-4",
                        "title": "Practical 4",
                        "content": "**Aim : Implementation and Time analysis of factorial program using iterative and\n recursive methods** \n\n```c\n#include <stdio.h>\n\n// Recursive method to calculate factorial\nlong long recursive_factorial(int n)\n{\n    if (n == 0 || n == 1)\n        return 1;\n    else\n        return n * recursive_factorial(n - 1);\n}\n\n// Iterative method to calculate factorial\nlong long iterative_factorial(int n)\n{\n    long long result = 1;\n    int i;\n\n    for (i = 2; i <= n; i++)\n    {\n        result *= i;\n    }\n    return result;\n}\n\nint main()\n{\n    int num;\n\n    printf(\"Enter a number to calculate factorial : \");\n    scanf(\"%d\", &num);\n\n    long long fact_recursive = recursive_factorial(num);\n    long long fact_iterative = iterative_factorial(num);\n\n    printf(\"\\nFactorial of %d using recursive method : %lld\", num, fact_recursive);\n    printf(\"\\nFactorial of %d using iterative method : %lld\\n\", num, fact_iterative);\n\n    return 0;\n}\n\n```\n\n```output\nEnter a number to calculate factorial : 5\n\nFactorial of 5 using recursive method : 120\nFactorial of 5 using iterative method : 120\n```\n<mark>Time Complexity Table</mark> \n| Method | Iterative Factorial | Recursive Factorial |\n| :--- | :--- | :--- |\n| **Worst Case** | O(n) | O(n) |\n| **Best Case** | O(n) | O(n) |\n| **Average Case** | O(n) | O(n) |\n"
                    },
                    {
                        "id": "practical-5",
                        "title": "Practical 5",
                        "content": "**Aim : Implementation of a knapsack problem using dynamic programming** \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// Function to find maximum of two numbers\nint max(int a, int b)\n{\n    return (a > b) ? a : b;\n}\n\n// Function to solve 0/1 Knapsack problem using Dynamic Programming\nint knapsack(int W, int weights[], int values[], int n)\n{\n    int i, w;\n\n    int **dp = (int **)malloc((n + 1) * sizeof(int *));\n    for (i = 0; i <= n; i++)\n        dp[i] = (int *)malloc((W + 1) * sizeof(int));\n\n    for (i = 0; i <= n; i++)\n    {\n        for (w = 0; w <= W; w++)\n        {\n            if (i == 0 || w == 0)\n                dp[i][w] = 0;\n            else if (weights[i - 1] <= w)\n                dp[i][w] = max(values[i - 1] + dp[i - 1][w - weights[i - 1]],\n                               dp[i - 1][w]);\n            else\n                dp[i][w] = dp[i - 1][w];\n        }\n    }\n\n    int result = dp[n][W];\n\n    for (i = 0; i <= n; i++)\n        free(dp[i]);\n    free(dp);\n\n    return result;\n}\n\nint main()\n{\n    int n, W, i;\n\n    printf(\"Enter number of items: \");\n    scanf(\"%d\", &n);\n\n    int *values = (int *)malloc(n * sizeof(int));\n    int *weights = (int *)malloc(n * sizeof(int));\n\n    printf(\"Enter values and weights of items:\\n\");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"Item %d value: \", i + 1);\n        scanf(\"%d\", &values[i]);\n\n        printf(\"Item %d weight: \", i + 1);\n        scanf(\"%d\", &weights[i]);\n    }\n\n    printf(\"Enter maximum knapsack capacity: \");\n    scanf(\"%d\", &W);\n\n    int maxValue = knapsack(W, weights, values, n);\n\n    printf(\"Maximum value in knapsack = %d\\n\", maxValue);\n\n    free(values);\n    free(weights);\n\n    return 0;\n}\n\n```\n\n```output\nEnter number of items: 3\nEnter values and weights of items:\nItem 1 value: 60\nItem 1 weight: 10\nItem 2 value: 100\nItem 2 weight: 20\nItem 3 value: 120\nItem 3 weight: 30\nEnter maximum knapsack capacity: 50\nMaximum value in knapsack = 220\n\n```\n<mark>Time Complexity Table</mark> \n| Problem | Best Case | Worst Case | Average Case |\n| :--- | :--- | :--- | :--- |\n| **0/1 Knapsack Problem** | O(n × W) | O(n × W) | O(n × W) |\n\n"
                    },
                    {
                        "id": "practical-6",
                        "title": "Practical 6",
                        "content": "**Aim : Implementation of chain matrix multiplication using dynamic programming.** \n\n```c\n#include <stdio.h>\n#include <limits.h>\n\n// Function for Matrix Chain Multiplication using DP\nint MatrixChainMultiplication(int p[], int n)\n{\n    int m[n][n];\n    int i, j, k, L, q;\n\n    // Cost is zero when multiplying one matrix\n    for (i = 1; i < n; i++)\n        m[i][i] = 0;\n\n    // L is chain length\n    for (L = 2; L < n; L++)\n    {\n        for (i = 1; i < n - L + 1; i++)\n        {\n            j = i + L - 1;\n            m[i][j] = INT_MAX;\n\n            for (k = i; k <= j - 1; k++)\n            {\n                q = m[i][k] + m[k + 1][j]\n                    + p[i - 1] * p[k] * p[j];\n\n                if (q < m[i][j])\n                    m[i][j] = q;\n            }\n        }\n    }\n\n    return m[1][n - 1];\n}\n\nint main()\n{\n    int n, i;\n\n    printf(\"Enter number of matrices: \");\n    scanf(\"%d\", &n);\n\n    // Number of dimensions = matrices + 1\n    n = n + 1;\n\n    int arr[n];\n\n    printf(\"Enter dimensions:\\n\");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"Enter d%d: \", i);\n        scanf(\"%d\", &arr[i]);\n    }\n\n    printf(\"\\nMinimum number of multiplications is %d\\n\",\n           MatrixChainMultiplication(arr, n));\n\n    return 0;\n}\n\n```\n\n```output\nEnter number of matrices: 3\nEnter dimensions:\nEnter d0: 10\nEnter d1: 20\nEnter d2: 30\nEnter d3: 40\n\nMinimum number of multiplications is 18000\n\n```\n<mark>Time Complexity Table</mark> \n| Problem | Best Case | Worst Case | Average Case |\n| :--- | :--- | :--- | :--- |\n| **Matrix Chain Multiplication** | O(n³) | O(n³) | O(n³) |\n\n"
                    },
                    {
                        "id": "practical-7",
                        "title": "Practical 7 ",
                        "content": "**Aim : Implementation of making a change problem using dynamic programming** \n\n\n```c\n#include <stdio.h>\n#include <limits.h>\n\n// Function to find minimum number of coins\nint minCoins(int coins[], int n, int amount)\n{\n    int dp[amount + 1];\n    int i, j;\n\n    for (i = 0; i <= amount; i++)\n        dp[i] = INT_MAX;\n\n    dp[0] = 0;\n\n    for (i = 1; i <= amount; i++)\n    {\n        for (j = 0; j < n; j++)\n        {\n            if (coins[j] <= i && dp[i - coins[j]] != INT_MAX)\n            {\n                if (dp[i] > dp[i - coins[j]] + 1)\n                    dp[i] = dp[i - coins[j]] + 1;\n            }\n        }\n    }\n\n    if (dp[amount] == INT_MAX)\n        return -1;\n    else\n        return dp[amount];\n}\n\nint main()\n{\n    int coins[] = {1, 3, 4};\n    int n = sizeof(coins) / sizeof(coins[0]);\n    int amount, i;\n\n    printf(\"Coins are fixed: \");\n    for (i = 0; i < n; i++)\n        printf(\"%d \", coins[i]);\n\n    printf(\"\\nEnter the target amount: \");\n    scanf(\"%d\", &amount);\n\n    printf(\"Target amount: %d\\n\", amount);\n\n    int result = minCoins(coins, n, amount);\n\n    if (result == -1)\n        printf(\"Change cannot be made for amount %d\\n\", amount);\n    else\n        printf(\"Minimum coins required: %d\\n\", result);\n\n    return 0;\n}\n\n```\n\n```output\nCoins are fixed: 1 3 4\nEnter the target amount: 6\nTarget amount: 6\nMinimum coins required: 2\n\n```\n<mark>Time Complexity Table</mark> \n| Problem | Best Case | Worst Case | Average Case |\n| :--- | :--- | :--- | :--- |\n| **Making a Change Problem** | O(n × amount) | O(n × amount) | O(n × amount) |\n\n"
                    },
                    {
                        "id": "practical-8",
                        "title": "Practical 8",
                        "content": "**Aim : Implementation of a knapsack problem using greedy algorithm** \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// Structure to store item details\ntypedef struct\n{\n    int value;\n    int weight;\n    double ratio;\n} Item;\n\n// Compare function for sorting items by value/weight ratio (descending)\nint compare(const void *a, const void *b)\n{\n    double r1 = ((Item *)a)->ratio;\n    double r2 = ((Item *)b)->ratio;\n\n    if (r1 < r2)\n        return 1;\n    else if (r1 > r2)\n        return -1;\n    else\n        return 0;\n}\n\n// Function to solve Fractional Knapsack using Greedy approach\ndouble fractionalKnapsack(int W, Item items[], int n)\n{\n    qsort(items, n, sizeof(Item), compare);\n\n    double totalValue = 0.0;\n    int i;\n\n    for (i = 0; i < n; i++)\n    {\n        if (items[i].weight <= W)\n        {\n            W -= items[i].weight;\n            totalValue += items[i].value;\n        }\n        else\n        {\n            totalValue += items[i].value * ((double)W / items[i].weight);\n            break;\n        }\n    }\n\n    return totalValue;\n}\n\nint main()\n{\n    int n, W, i;\n\n    printf(\"Enter number of items: \");\n    scanf(\"%d\", &n);\n\n    Item *items = (Item *)malloc(n * sizeof(Item));\n\n    printf(\"Enter values and weights of items:\\n\");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"Item %d value: \", i + 1);\n        scanf(\"%d\", &items[i].value);\n\n        printf(\"Item %d weight: \", i + 1);\n        scanf(\"%d\", &items[i].weight);\n\n        items[i].ratio = (double)items[i].value / items[i].weight;\n    }\n\n    printf(\"Enter maximum knapsack capacity: \");\n    scanf(\"%d\", &W);\n\n    double maxValue = fractionalKnapsack(W, items, n);\n\n    printf(\"Maximum value in knapsack = %.2lf\\n\", maxValue);\n\n    free(items);\n\n    return 0;\n}\n\n```\n\n```output\nEnter number of items: 3\nEnter values and weights of items:\nItem 1 value: 60\nItem 1 weight: 10\nItem 2 value: 100\nItem 2 weight: 20\nItem 3 value: 120\nItem 3 weight: 30\nEnter maximum knapsack capacity: 50\nMaximum value in knapsack = 240.00\n\n```\n<mark>Time Complexity Table</mark> \n| Problem | Best Case | Worst Case | Average Case |\n| :--- | :--- | :--- | :--- |\n| **Fractional Knapsack (Greedy)** | O(n log n) | O(n log n) | O(n log n) |\n\n"
                    },
                    {
                        "id": "practical-9",
                        "title": "Practical 9",
                        "content": "**Aim: Implementation of Graph and Searching (DFS and BFS).** \n\n```c\n#include <stdio.h>\n#define SIZE 10\n\n// Function to print adjacency matrix\nvoid printMatrix(int matrix[SIZE][SIZE])\n{\n    int i, j;\n    printf(\"\\nAdjacency Matrix:\\n\");\n    for (i = 0; i < SIZE; i++)\n    {\n        for (j = 0; j < SIZE; j++)\n            printf(\"%d \", matrix[i][j]);\n        printf(\"\\n\");\n    }\n}\n\n// DFS utility function\nvoid DFSUtil(int matrix[SIZE][SIZE], int visited[SIZE], int v)\n{\n    visited[v] = 1;\n    printf(\"%d \", v);\n\n    int i;\n    for (i = 0; i < SIZE; i++)\n    {\n        if (matrix[v][i] == 1 && !visited[i])\n            DFSUtil(matrix, visited, i);\n    }\n}\n\n// DFS traversal\nvoid DFS(int matrix[SIZE][SIZE], int start)\n{\n    int visited[SIZE] = {0};\n    printf(\"\\nDFS Traversal: \");\n    DFSUtil(matrix, visited, start);\n    printf(\"\\n\");\n}\n\n// BFS traversal\nvoid BFS(int matrix[SIZE][SIZE], int start)\n{\n    int visited[SIZE] = {0};\n    int queue[SIZE], front = 0, rear = 0;\n\n    visited[start] = 1;\n    queue[rear++] = start;\n\n    printf(\"BFS Traversal: \");\n\n    while (front < rear)\n    {\n        int v = queue[front++];\n        printf(\"%d \", v);\n\n        int i;\n        for (i = 0; i < SIZE; i++)\n        {\n            if (matrix[v][i] == 1 && !visited[i])\n            {\n                visited[i] = 1;\n                queue[rear++] = i;\n            }\n        }\n    }\n    printf(\"\\n\");\n}\n\nint main()\n{\n    int matrix[SIZE][SIZE] = {0};\n    int edges, i;\n\n    printf(\"Enter number of edges: \");\n    scanf(\"%d\", &edges);\n\n    printf(\"Enter edges (from to):\\n\");\n    for (i = 0; i < edges; i++)\n    {\n        int from, to;\n        scanf(\"%d %d\", &from, &to);\n\n        if (from >= 0 && from < SIZE && to >= 0 && to < SIZE)\n        {\n            matrix[from][to] = 1;\n            matrix[to][from] = 1; // Undirected graph\n        }\n        else\n        {\n            printf(\"Invalid input. Use digits 0–9 only.\\n\");\n            i--; // Retry\n        }\n    }\n\n    printMatrix(matrix);\n\n    int start;\n    printf(\"\\nEnter starting vertex (0–9): \");\n    scanf(\"%d\", &start);\n\n    if (start >= 0 && start < SIZE)\n    {\n        DFS(matrix, start);\n        BFS(matrix, start);\n    }\n    else\n    {\n        printf(\"Invalid starting vertex.\\n\");\n    }\n\n    return 0;\n}\n\n```\n\n```output\nEnter number of edges: 4\nEnter edges (from to):\n0 1\n0 2\n1 3\n2 3\n\nAdjacency Matrix:\n0 1 1 0 0 0 0 0 0 0\n1 0 0 1 0 0 0 0 0 0\n1 0 0 1 0 0 0 0 0 0\n0 1 1 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n\nEnter starting vertex (0–9): 0\n\nDFS Traversal: 0 1 3 2\nBFS Traversal: 0 1 2 3\n\n```\n<mark>Time Complexity Table</mark> \n| Algorithm | Best Case | Worst Case | Average Case |\n| :--- | :--- | :--- | :--- |\n| **DFS** | O(V + E) | O(V + E) | O(V + E) |\n| **BFS** | O(V + E) | O(V + E) | O(V + E) |\n\n"
                    },
                    {
                        "id": "practical-10",
                        "title": "Practical 10",
                        "content": "**Aim: Implementation of Prim’s Algorithm to find Minimum Spanning Tree (MST)** \n\n```c\n#include <stdio.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define V 5\n\n// Function to find the vertex with minimum key value\nint minKey(int key[], bool mstSet[])\n{\n    int min = INT_MAX, min_index = -1;\n\n    for (int v = 0; v < V; v++)\n    {\n        if (!mstSet[v] && key[v] < min)\n        {\n            min = key[v];\n            min_index = v;\n        }\n    }\n    return min_index;\n}\n\n// Function to implement Prim's Algorithm\nvoid primMST(int graph[V][V])\n{\n    int parent[V];\n    int key[V];\n    bool mstSet[V];\n    int total = 0;\n\n    for (int i = 0; i < V; i++)\n    {\n        key[i] = INT_MAX;\n        mstSet[i] = false;\n    }\n\n    key[0] = 0;\n    parent[0] = -1;\n\n    for (int count = 0; count < V - 1; count++)\n    {\n        int u = minKey(key, mstSet);\n        mstSet[u] = true;\n\n        for (int v = 0; v < V; v++)\n        {\n            if (graph[u][v] && !mstSet[v] && graph[u][v] < key[v])\n            {\n                parent[v] = u;\n                key[v] = graph[u][v];\n            }\n        }\n    }\n\n    printf(\"Edge   Weight\\n\");\n    for (int i = 1; i < V; i++)\n    {\n        printf(\"%d - %d    %d\\n\", parent[i], i, graph[i][parent[i]]);\n        total += graph[i][parent[i]];\n    }\n\n    printf(\"Total weight of MST: %d\\n\", total);\n}\n\nint main()\n{\n    int graph[V][V] = {\n        {0, 1, 0, 0, 0},\n        {1, 0, 0, 0, 2},\n        {0, 0, 0, 0, 0},\n        {0, 0, 0, 0, 0},\n        {0, 2, 0, 0, 0}\n    };\n\n    primMST(graph);\n\n    return 0;\n}\n\n```\n\n```output\nEdge   Weight\n0 - 1    1\n1 - 4    2\nTotal weight of MST: 3\n\n```\n<mark>Time Complexity Table</mark> \n| Algorithm | Best Case | Worst Case | Average Case |\n| :--- | :--- | :--- | :--- |\n| **Prim’s Algorithm** | O(V²) | O(V²) | O(V²) |\n\n\n"
                    },
                    {
                        "id": "practical-11",
                        "title": "Practical 11",
                        "content": "**Aim: Implement kruskal’s algorithm to find Minimum Spanning Tree (MST).** \n\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define V 5   // Number of vertices\n#define E 7   // Number of edges\n\n// Structure to represent an edge\ntypedef struct\n{\n    int src, dest, weight;\n} Edge;\n\n// Structure for Union-Find\ntypedef struct\n{\n    int parent;\n    int rank;\n} Subset;\n\n// Compare edges by weight\nint compareEdges(const void *a, const void *b)\n{\n    Edge *ea = (Edge *)a;\n    Edge *eb = (Edge *)b;\n    return ea->weight - eb->weight;\n}\n\n// Find with path compression\nint find(Subset subsets[], int i)\n{\n    if (subsets[i].parent != i)\n        subsets[i].parent = find(subsets, subsets[i].parent);\n    return subsets[i].parent;\n}\n\n// Union by rank\nvoid unionSets(Subset subsets[], int x, int y)\n{\n    int xroot = find(subsets, x);\n    int yroot = find(subsets, y);\n\n    if (subsets[xroot].rank < subsets[yroot].rank)\n        subsets[xroot].parent = yroot;\n    else if (subsets[xroot].rank > subsets[yroot].rank)\n        subsets[yroot].parent = xroot;\n    else\n    {\n        subsets[yroot].parent = xroot;\n        subsets[xroot].rank++;\n    }\n}\n\n// Kruskal’s Algorithm\nvoid kruskalMST(Edge edges[], int n)\n{\n    qsort(edges, n, sizeof(Edge), compareEdges);\n\n    Subset subsets[V];\n    for (int v = 0; v < V; v++)\n    {\n        subsets[v].parent = v;\n        subsets[v].rank = 0;\n    }\n\n    Edge result[V - 1];\n    int e = 0, i = 0, total = 0;\n\n    while (e < V - 1 && i < n)\n    {\n        Edge next = edges[i++];\n\n        int x = find(subsets, next.src);\n        int y = find(subsets, next.dest);\n\n        if (x != y)\n        {\n            result[e++] = next;\n            unionSets(subsets, x, y);\n            total += next.weight;\n        }\n    }\n\n    printf(\"Edge   Weight\\n\");\n    for (i = 0; i < e; i++)\n        printf(\"%d - %d    %d\\n\", result[i].src, result[i].dest, result[i].weight);\n\n    printf(\"Total weight of MST: %d\\n\", total);\n}\n\nint main()\n{\n    Edge edges[E] = {\n        {0, 1, 1},\n        {1, 4, 2},\n        {0, 2, 3},\n        {1, 2, 4},\n        {2, 3, 5},\n        {3, 4, 6},\n        {0, 4, 7}\n    };\n\n    kruskalMST(edges, E);\n\n    return 0;\n}\n\n```\n\n```output\nEdge   Weight\n0 - 1    1\n1 - 4    2\n0 - 2    3\n2 - 3    5\nTotal weight of MST: 11\n\n```\n<mark>Time Complexity Table</mark> \n| Algorithm | Best Case | Worst Case | Average Case |\n| :--- | :--- | :--- | :--- |\n| **Kruskal’s Algorithm** | O(E log E) | O(E log E) | O(E log E) |\n\n\n"
                    },
                    {
                        "id": "practical-12",
                        "title": "Practical 12",
                        "content": "**Aim: Implementation of Longest Common Subsequence (LCS) Problem using Dynamic Programming** \n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n// Function to find and print LCS\nvoid printLCS(char *X, char *Y)\n{\n    int m = strlen(X);\n    int n = strlen(Y);\n    int dp[m + 1][n + 1];\n    int i, j;\n\n    // Build DP table\n    for (i = 0; i <= m; i++)\n    {\n        for (j = 0; j <= n; j++)\n        {\n            if (i == 0 || j == 0)\n                dp[i][j] = 0;\n            else if (X[i - 1] == Y[j - 1])\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            else\n                dp[i][j] = (dp[i - 1][j] > dp[i][j - 1]) ?\n                            dp[i - 1][j] : dp[i][j - 1];\n        }\n    }\n\n    // Length of LCS\n    int index = dp[m][n];\n\n    // Create LCS string\n    char *lcs = (char *)malloc((index + 1) * sizeof(char));\n    lcs[index] = '\\0';\n\n    // Backtracking to find LCS\n    i = m;\n    j = n;\n    while (i > 0 && j > 0)\n    {\n        if (X[i - 1] == Y[j - 1])\n        {\n            lcs[index - 1] = X[i - 1];\n            i--;\n            j--;\n            index--;\n        }\n        else if (dp[i - 1][j] > dp[i][j - 1])\n            i--;\n        else\n            j--;\n    }\n\n    // Output\n    printf(\"String Pattern X: %s\\n\", X);\n    printf(\"String Text Y   : %s\\n\", Y);\n    printf(\"Length of LCS   : %d\\n\", dp[m][n]);\n    printf(\"LCS             : %s\\n\", lcs);\n\n    free(lcs);\n}\n\nint main()\n{\n    // Website name split as requested\n    char X[] = \"NOTES\";\n    char Y[] = \"WALA\";\n\n    printLCS(X, Y);\n\n    return 0;\n}\n\n```\n\n```output\nString Pattern X: NOTES\nString Text Y   : WALA\nLength of LCS   : 1\nLCS             : A\n\n```\n<mark>Time Complexity Table</mark> \n| Problem | Best Case | Worst Case | Average Case |\n| :--- | :--- | :--- | :--- |\n| **LCS Problem** | O(m × n) | O(m × n) | O(m × n) |\n"
                    }
                ]
            },
            {
                "id": "ipdc",
                "title": "IPDC",
                "chapters": []
            },
            {
                "id": "software-engineering",
                "title": "Software Engineering",
                "chapters": []
            }
        ],
        "locked": true
    },
    {
        "id": "semester-6",
        "title": "Semester 6",
        "description": "Topic",
        "subjects": [],
        "locked": true
    },
    {
        "id": "semester-7",
        "title": "Semester 7",
        "description": "Topic",
        "subjects": [],
        "locked": true
    },
    {
        "id": "semester-8",
        "title": "Semester 8",
        "description": "Topic",
        "subjects": [],
        "locked": true
    }
]